{"mappings":"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","sources":["<anon>","src/big-json-viewer-service.ts","src/parser/json-node-search.ts","src/parser/buffer-json-parser.ts","src/helpers/utils.ts","src/parser/js-parser.ts","docs-src/demo.ts","src/index.ts","src/big-json-viewer-dom.ts","src/helpers/worker-client.ts","src/worker/big-json-viewer.worker.inline.ts","src/model/big-json-viewer.model.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire13a7\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire13a7\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"dpnMS\", function(module, exports) {\n\n$parcel$export(module.exports, \"BigJsonViewerService\", () => $5a6657ab2d9f6108$export$8df78c6654d8a3cf);\n\nvar $jl3no = parcelRequire(\"jl3no\");\n\nvar $bjTst = parcelRequire(\"bjTst\");\n\nvar $7vO2F = parcelRequire(\"7vO2F\");\nclass $5a6657ab2d9f6108$export$8df78c6654d8a3cf {\n    initWithData(data) {\n        this.rootNode = new (0, $bjTst.BufferJsonParser)(data).getRootNodeInfo();\n        return this.getRenderInfo(this.rootNode);\n    }\n    initWithJs(data) {\n        this.rootNode = new (0, $7vO2F.JsParser)(data).getRootNodeInfo();\n        return this.getRenderInfo(this.rootNode);\n    }\n    getNodes(path, start, limit) {\n        const node = this.rootNode.getByPath(path);\n        if (node && node.type === 'object') return node.getObjectNodes(start, limit).map((n)=>this.getRenderInfo(n));\n        if (node && node.type === 'array') return node.getArrayNodes(start, limit).map((n)=>this.getRenderInfo(n));\n        return null;\n    }\n    getKeyIndex(path, key) {\n        const node = this.rootNode.getByPath(path);\n        if (!node) return -1;\n        const keys = node.getObjectKeys();\n        return keys.indexOf(key);\n    }\n    search(pattern, searchArea) {\n        return (0, $jl3no.searchJsonNodes)(this.rootNode, pattern, searchArea);\n    }\n    getRenderInfo(node) {\n        const info = {\n            type: node.type,\n            length: node.length,\n            path: node.path,\n            openable: this.isOpenableNode(node)\n        };\n        if (!info.openable) info.value = node.getValue();\n        return info;\n    }\n    isOpenableNode(node) {\n        return (node.type === 'array' || node.type === 'object') && !!node.length;\n    }\n}\n\n});\nparcelRegister(\"jl3no\", function(module, exports) {\n\n$parcel$export(module.exports, \"searchJsonNodes\", () => $8d78a578d08ef2f3$export$e47f93b04bb8867c);\n$parcel$export(module.exports, \"forEachMatchFromString\", () => $8d78a578d08ef2f3$export$57f00ad7da2077f5);\nfunction $8d78a578d08ef2f3$export$e47f93b04bb8867c(node, pattern, searchArea = 'all') {\n    pattern = $8d78a578d08ef2f3$var$ensureGlobal(pattern);\n    const results = [];\n    if (node.path.length && (searchArea === 'all' || searchArea === 'keys')) $8d78a578d08ef2f3$export$57f00ad7da2077f5(pattern, node.path[node.path.length - 1], (index, length)=>{\n        results.push({\n            path: node.path,\n            key: index,\n            length: length\n        });\n    });\n    if (node.type === 'object') node.getObjectNodes().forEach((subNode)=>{\n        results.push(...$8d78a578d08ef2f3$export$e47f93b04bb8867c(subNode, pattern, searchArea));\n    });\n    else if (node.type === 'array') node.getArrayNodes().forEach((subNode)=>{\n        results.push(...$8d78a578d08ef2f3$export$e47f93b04bb8867c(subNode, pattern, searchArea));\n    });\n    else if (searchArea === 'all' || searchArea === 'values') $8d78a578d08ef2f3$export$57f00ad7da2077f5(pattern, String(node.getValue()), (index, length)=>{\n        results.push({\n            path: node.path,\n            value: index,\n            length: length\n        });\n    });\n    return results;\n}\nfunction $8d78a578d08ef2f3$export$57f00ad7da2077f5(pattern, subject, callback) {\n    pattern = $8d78a578d08ef2f3$var$ensureGlobal(pattern);\n    pattern.lastIndex = 0;\n    let match = null;\n    while((match = pattern.exec(subject)) !== null)callback(match.index, match[0].length);\n    pattern.lastIndex = 0;\n}\nfunction $8d78a578d08ef2f3$var$ensureGlobal(pattern) {\n    if (!pattern.global) {\n        const flags = 'g' + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '');\n        return new RegExp(pattern.source, flags);\n    }\n    return pattern;\n}\n\n});\n\nparcelRegister(\"bjTst\", function(module, exports) {\n\n$parcel$export(module.exports, \"BufferJsonParser\", () => $8b51f9b9b5b272ca$export$8563104a25517665);\n\nvar $3NxB6 = parcelRequire(\"3NxB6\");\nconst $8b51f9b9b5b272ca$var$BRACE_START = '{'.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$BRACE_END = '}'.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$BRACKET_START = '['.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$BRACKET_END = ']'.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$COLON = ':'.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$COMMA = ','.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$DOUBLE_QUOTE = '\"'.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$SINGLE_QUOTE = \"'\".charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$SPACE = ' '.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$TAB = '\\t'.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$NEWLINE = '\\n'.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$BACKSPACE = '\\b'.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$CARRIAGE_RETURN = '\\r'.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$FORM_FEED = '\\f'.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$BACK_SLASH = '\\\\'.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$FORWARD_SLASH = '/'.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$MINUS = '-'.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$PLUS = '+'.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$DOT = '.'.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$CHAR_E_LOW = 'e'.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$CHAR_E_HIGH = 'E'.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$DIGIT_0 = '0'.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$DIGIT_9 = '9'.charCodeAt(0);\nconst $8b51f9b9b5b272ca$var$IGNORED = [\n    $8b51f9b9b5b272ca$var$SPACE,\n    $8b51f9b9b5b272ca$var$TAB,\n    $8b51f9b9b5b272ca$var$NEWLINE,\n    $8b51f9b9b5b272ca$var$CARRIAGE_RETURN\n];\nconst $8b51f9b9b5b272ca$var$NULL = 'null'.split('').map((d)=>d.charCodeAt(0));\nconst $8b51f9b9b5b272ca$var$TRUE = 'true'.split('').map((d)=>d.charCodeAt(0));\nconst $8b51f9b9b5b272ca$var$FALSE = 'false'.split('').map((d)=>d.charCodeAt(0));\nclass $8b51f9b9b5b272ca$export$c3a21231378bfea9 {\n    constructor(parser, index, path){\n        this.path = [];\n        this.parser = parser;\n        this.index = index;\n        this.path = path;\n    }\n    /**\n   * Returns the list of keys in case of an object for the defined range\n   * @param {number} start\n   * @param {number} limit\n   */ getObjectKeys(start = 0, limit) {\n        if (this.type !== 'object') throw new Error(`Unsupported method on non-object ${this.type}`);\n        (0, $3NxB6.assertStartLimit)(start, limit);\n        const ctx = {\n            path: this.path,\n            objectKeys: [],\n            start: start,\n            limit: limit\n        };\n        this.parser.parseObject(this.index, ctx);\n        return ctx.objectKeys;\n    }\n    /**\n   * Return the NodeInfo at the defined position.\n   * Use the index from getObjectKeys\n   * @param index\n   */ getByIndex(index) {\n        if (this.type === 'object') {\n            const nodes = this.getObjectNodes(index, 1);\n            if (nodes.length) return nodes[0];\n        }\n        if (this.type === 'array') {\n            const nodes = this.getArrayNodes(index, 1);\n            if (nodes.length) return nodes[0];\n        }\n        return undefined;\n    }\n    /**\n   * Return the NodeInfo for the specified key\n   * Use the index from getObjectKeys\n   * @param key\n   */ getByKey(key) {\n        if (this.type === 'object') {\n            const ctx = {\n                path: this.path,\n                objectKey: key\n            };\n            this.parser.parseObject(this.index, ctx);\n            return ctx.objectNodes ? ctx.objectNodes[0] : undefined;\n        }\n        if (this.type === 'array') return this.getByIndex(parseInt(key));\n        return undefined;\n    }\n    /**\n   * Find the information for a given path\n   * @param {string[]} path\n   */ getByPath(path) {\n        if (!path) return undefined;\n        if (!path.length) return this;\n        const p = path.slice();\n        let key;\n        let node = this;\n        while((key = p.shift()) !== undefined && node)node = node.getByKey(key);\n        return node;\n    }\n    /**\n   * Returns a list with the NodeInfo objects for the defined range\n   * @param {number} start\n   * @param {number} limit\n   */ getObjectNodes(start = 0, limit) {\n        if (this.type !== 'object') throw new Error(`Unsupported method on non-object ${this.type}`);\n        (0, $3NxB6.assertStartLimit)(start, limit);\n        const ctx = {\n            path: this.path,\n            objectNodes: [],\n            start: start,\n            limit: limit\n        };\n        this.parser.parseObject(this.index, ctx);\n        return ctx.objectNodes;\n    }\n    /**\n   * Returns a list of NodeInfo for the defined range\n   * @param {number} start\n   * @param {number} limit\n   */ getArrayNodes(start = 0, limit) {\n        if (this.type !== 'array') throw new Error(`Unsupported method on non-array ${this.type}`);\n        (0, $3NxB6.assertStartLimit)(start, limit);\n        const ctx = {\n            path: this.path,\n            arrayNodes: [],\n            start: start,\n            limit: limit\n        };\n        this.parser.parseArray(this.index, ctx);\n        return ctx.arrayNodes;\n    }\n    /**\n   * Get the natively parsed value\n   */ getValue() {\n        return this.parser.parseNative(this.index, this.index + this.chars);\n    }\n}\nclass $8b51f9b9b5b272ca$export$8563104a25517665 {\n    constructor(data){\n        if (data instanceof ArrayBuffer) this.data = new Uint16Array(data);\n        else if (typeof data === 'string' && typeof TextEncoder !== 'undefined') this.data = new TextEncoder().encode(data);\n        else if (typeof data === 'string') {\n            this.data = new Uint16Array(new ArrayBuffer(data.length * 2));\n            for(let i = 0; i < data.length; i++)this.data[i] = data.charCodeAt(i);\n        }\n    }\n    getRootNodeInfo() {\n        let start = this.skipIgnored(0);\n        const ctx = {\n            path: [],\n            nodeInfo: new $8b51f9b9b5b272ca$export$c3a21231378bfea9(this, start, [])\n        };\n        const end = this.parseValue(start, ctx, false);\n        if (start === end) return null;\n        return ctx.nodeInfo;\n    }\n    parseValue(start, ctx, throwUnknown = true) {\n        const char = this.data[start];\n        if (isString(char)) return this.parseString(start, ctx);\n        if (isNumber(char)) return this.parseNumber(start, ctx);\n        if (char === $8b51f9b9b5b272ca$var$BRACE_START) return this.parseObject(start, ctx);\n        if (char === $8b51f9b9b5b272ca$var$BRACKET_START) return this.parseArray(start, ctx);\n        if (char === $8b51f9b9b5b272ca$var$TRUE[0]) return this.parseToken(start, $8b51f9b9b5b272ca$var$TRUE, ctx);\n        if (char === $8b51f9b9b5b272ca$var$FALSE[0]) return this.parseToken(start, $8b51f9b9b5b272ca$var$FALSE, ctx);\n        if (char === $8b51f9b9b5b272ca$var$NULL[0]) return this.parseToken(start, $8b51f9b9b5b272ca$var$NULL, ctx);\n        if (throwUnknown) throw new Error(`parse value unknown token ${$8b51f9b9b5b272ca$var$bufToString(char)} at ${start}`);\n        function isString(char) {\n            return char === $8b51f9b9b5b272ca$var$DOUBLE_QUOTE || char === $8b51f9b9b5b272ca$var$SINGLE_QUOTE;\n        }\n        function isNumber(char) {\n            return char === $8b51f9b9b5b272ca$var$MINUS || char >= $8b51f9b9b5b272ca$var$DIGIT_0 && char <= $8b51f9b9b5b272ca$var$DIGIT_9;\n        }\n    }\n    parseObject(start, ctx) {\n        let index = start + 1; // skip the start brace\n        let length = 0;\n        const keys = [];\n        const nodes = [];\n        while(index <= this.data.length){\n            if (index === this.data.length) throw new Error(`parse object incomplete at end`);\n            index = this.skipIgnored(index);\n            if (this.data[index] === $8b51f9b9b5b272ca$var$BRACE_END) {\n                index++;\n                break;\n            }\n            const keyCtx = getKeyContext(length);\n            index = this.parseString(index, keyCtx);\n            if (keyCtx && ctx && ctx.objectKeys) keys.push(keyCtx.value);\n            index = this.skipIgnored(index);\n            if (this.data[index] !== $8b51f9b9b5b272ca$var$COLON) throw new Error(`parse object unexpected token ${$8b51f9b9b5b272ca$var$bufToString(this.data[index])} at ${index}. Expected :`);\n            else index++;\n            index = this.skipIgnored(index);\n            let valueCtx = null;\n            if (keyCtx && ctx && (ctx.objectNodes || keyCtx.value === ctx.objectKey)) valueCtx = {\n                path: ctx.path,\n                nodeInfo: new $8b51f9b9b5b272ca$export$c3a21231378bfea9(this, index, [\n                    ...ctx.path,\n                    keyCtx.value\n                ])\n            };\n            index = this.parseValue(index, valueCtx);\n            index = this.skipIgnored(index);\n            if (valueCtx && ctx.objectNodes) nodes.push(valueCtx.nodeInfo);\n            else if (valueCtx && ctx.objectKey !== undefined) {\n                ctx.objectNodes = [\n                    valueCtx.nodeInfo\n                ];\n                return;\n            }\n            length++;\n            if (this.data[index] === $8b51f9b9b5b272ca$var$COMMA) index++;\n            else if (this.data[index] !== $8b51f9b9b5b272ca$var$BRACE_END) throw new Error(`parse object unexpected token ${$8b51f9b9b5b272ca$var$bufToString(this.data[index])} at ${index}. Expected , or }`);\n        }\n        if (ctx && ctx.nodeInfo) {\n            ctx.nodeInfo.type = 'object';\n            ctx.nodeInfo.length = length;\n            ctx.nodeInfo.chars = index - start;\n        }\n        if (ctx && ctx.objectKeys) ctx.objectKeys = keys;\n        if (ctx && ctx.objectNodes) ctx.objectNodes = nodes;\n        function getKeyContext(keyIndex) {\n            if (!ctx || ctx.start && keyIndex < ctx.start || ctx.limit && keyIndex >= ctx.start + ctx.limit) return null;\n            if (ctx && (ctx.objectKeys || ctx.objectNodes || ctx.objectKey !== undefined)) return {\n                path: ctx.path,\n                value: null\n            };\n            return null;\n        }\n        return index;\n    }\n    parseArray(start, ctx) {\n        let index = start + 1; // skip the start bracket\n        let length = 0;\n        while(index <= this.data.length){\n            if (index === this.data.length) throw new Error(`parse array incomplete at end`);\n            index = this.skipIgnored(index);\n            if (this.data[index] === $8b51f9b9b5b272ca$var$BRACKET_END) {\n                index++;\n                break;\n            }\n            let valueCtx = null;\n            if (isInRange(length) && ctx.arrayNodes) valueCtx = {\n                path: ctx.path,\n                nodeInfo: new $8b51f9b9b5b272ca$export$c3a21231378bfea9(this, index, [\n                    ...ctx.path,\n                    length.toString()\n                ])\n            };\n            index = this.parseValue(index, valueCtx);\n            if (valueCtx) ctx.arrayNodes.push(valueCtx.nodeInfo);\n            index = this.skipIgnored(index);\n            length++;\n            if (this.data[index] === $8b51f9b9b5b272ca$var$COMMA) index++;\n            else if (this.data[index] !== $8b51f9b9b5b272ca$var$BRACKET_END) throw new Error(`parse array unexpected token ${$8b51f9b9b5b272ca$var$bufToString(this.data[index])} at ${index}. Expected , or ]`);\n        }\n        if (ctx && ctx.nodeInfo) {\n            ctx.nodeInfo.type = 'array';\n            ctx.nodeInfo.length = length;\n            ctx.nodeInfo.chars = index - start;\n        }\n        function isInRange(keyIndex) {\n            return !(!ctx || ctx.start && keyIndex < ctx.start || ctx.limit && keyIndex >= ctx.start + ctx.limit);\n        }\n        return index;\n    }\n    parseString(start, ctx) {\n        let index = start;\n        const expect = this.data[index] === $8b51f9b9b5b272ca$var$DOUBLE_QUOTE ? $8b51f9b9b5b272ca$var$DOUBLE_QUOTE : $8b51f9b9b5b272ca$var$SINGLE_QUOTE;\n        let esc = false, length = 0;\n        for(index++; index <= this.data.length; index++){\n            if (index === this.data.length) throw new Error(`parse string incomplete at end`);\n            if (!esc && this.data[index] === expect) {\n                index++;\n                break;\n            }\n            if (this.data[index] === $8b51f9b9b5b272ca$var$BACK_SLASH) esc = !esc;\n            else esc = false;\n            if (!esc) length++;\n        }\n        if (ctx && ctx.nodeInfo) {\n            ctx.nodeInfo.type = 'string';\n            ctx.nodeInfo.length = length;\n            ctx.nodeInfo.chars = index - start;\n        }\n        if (ctx && ctx.value !== undefined) ctx.value = JSON.parse($8b51f9b9b5b272ca$var$bufToString(this.data.subarray(start, index)));\n        return index;\n    }\n    parseNumber(start, ctx) {\n        let i = start;\n        if (this.data[i] === $8b51f9b9b5b272ca$var$MINUS) i++;\n        i = this.parseDigits(i);\n        if (this.data[i] === $8b51f9b9b5b272ca$var$DOT) {\n            i++;\n            i = this.parseDigits(i);\n        }\n        if (this.data[i] === $8b51f9b9b5b272ca$var$CHAR_E_HIGH || this.data[i] === $8b51f9b9b5b272ca$var$CHAR_E_LOW) {\n            i++;\n            if (this.data[i] === $8b51f9b9b5b272ca$var$PLUS || this.data[i] === $8b51f9b9b5b272ca$var$MINUS) i++;\n            i = this.parseDigits(i);\n        }\n        if (ctx && ctx.nodeInfo) {\n            ctx.nodeInfo.type = 'number';\n            ctx.nodeInfo.chars = i - start;\n        }\n        if (ctx && ctx.value !== undefined) ctx.value = JSON.parse($8b51f9b9b5b272ca$var$bufToString(this.data.subarray(start, i)));\n        return i;\n    }\n    parseDigits(start) {\n        while(this.data[start] >= $8b51f9b9b5b272ca$var$DIGIT_0 && this.data[start] <= $8b51f9b9b5b272ca$var$DIGIT_9)start++;\n        return start;\n    }\n    parseToken(start, chars, ctx) {\n        let index = start;\n        for(let i = 0; i < chars.length; i++){\n            if (this.data[index] !== chars[i]) throw new Error(`Unexpected token ${$8b51f9b9b5b272ca$var$bufToString(this.data[index])} at ${index}. Expected ${$8b51f9b9b5b272ca$var$bufToString(chars)}`);\n            index++;\n        }\n        const token = $8b51f9b9b5b272ca$var$bufToString(this.data.subarray(start, index));\n        if (ctx && ctx.nodeInfo) {\n            if (token === 'null') ctx.nodeInfo.type = 'null';\n            else ctx.nodeInfo.type = 'boolean';\n            ctx.nodeInfo.chars = index - start;\n        }\n        if (ctx && ctx.value !== undefined) ctx.value = JSON.parse(token);\n        return index;\n    }\n    parseNative(start, end) {\n        return JSON.parse($8b51f9b9b5b272ca$var$bufToString(this.data.subarray(start, end)));\n    }\n    skipIgnored(start) {\n        for(let i = start; i < this.data.length; i++){\n            if ($8b51f9b9b5b272ca$var$IGNORED.indexOf(this.data[i]) !== -1) continue;\n            return i;\n        }\n    }\n}\nfunction $8b51f9b9b5b272ca$var$bufToString(buf) {\n    if (typeof buf === 'number') buf = [\n        buf\n    ];\n    return String.fromCharCode.apply(null, buf);\n}\n\n});\nparcelRegister(\"3NxB6\", function(module, exports) {\n\n$parcel$export(module.exports, \"assertStartLimit\", () => $63f21e5cf8cde4d8$export$dcfa27f977c5224c);\nfunction $63f21e5cf8cde4d8$export$dcfa27f977c5224c(start, limit) {\n    if (isNaN(start) || start < 0) throw new Error(`Invalid start ${start}`);\n    if (limit && limit < 0) throw new Error(`Invalid limit ${limit}`);\n}\n\n});\n\n\nparcelRegister(\"7vO2F\", function(module, exports) {\n\n$parcel$export(module.exports, \"JsParser\", () => $04e605f16dc82b7e$export$ff409fe831d40557);\n\nvar $3NxB6 = parcelRequire(\"3NxB6\");\nclass $04e605f16dc82b7e$export$defd4a491b161b4d {\n    constructor(ref, path){\n        this.path = [];\n        this.ref = ref;\n        this.path = path;\n        const jsType = typeof ref;\n        if (jsType === 'undefined') this.type = 'undefined';\n        if (jsType === 'symbol') this.type = 'symbol';\n        if (jsType === 'function') this.type = 'function';\n        if (jsType === 'object' && ref === null) this.type = 'null';\n        else if (jsType === 'object' && Array.isArray(ref)) this.type = 'array';\n        else this.type = jsType;\n        if (this.type === 'object') this.length = Object.keys(ref).length;\n        if (this.type === 'array' || this.type === 'string') this.length = ref.length;\n    }\n    /**\n   * Returns the list of keys in case of an object for the defined range\n   * @param {number} start\n   * @param {number} limit\n   */ getObjectKeys(start = 0, limit) {\n        if (this.type !== 'object') throw new Error(`Unsupported method on non-object ${this.type}`);\n        (0, $3NxB6.assertStartLimit)(start, limit);\n        const keys = Object.keys(this.ref);\n        if (limit) return keys.slice(start, start + limit);\n        return keys.slice(start);\n    }\n    /**\n   * Return the NodeInfo at the defined position.\n   * Use the index from getObjectKeys\n   * @param index\n   */ getByIndex(index) {\n        if (this.type === 'object') {\n            const nodes = this.getObjectNodes(index, 1);\n            if (nodes.length) return nodes[0];\n        }\n        if (this.type === 'array') {\n            const nodes = this.getArrayNodes(index, 1);\n            if (nodes.length) return nodes[0];\n        }\n        return undefined;\n    }\n    /**\n   * Return the NodeInfo for the specified key\n   * Use the index from getObjectKeys\n   * @param key\n   */ getByKey(key) {\n        if (this.type === 'object' && this.ref.hasOwnProperty(key)) return new $04e605f16dc82b7e$export$defd4a491b161b4d(this.ref[key], [\n            ...this.path,\n            key\n        ]);\n        if (this.type === 'array') return this.getByIndex(parseInt(key));\n        return undefined;\n    }\n    /**\n   * Find the information for a given path\n   * @param {string[]} path\n   */ getByPath(path) {\n        if (!path) return undefined;\n        if (!path.length) return this;\n        const p = path.slice();\n        let key;\n        let node = this;\n        while((key = p.shift()) !== undefined && node)node = node.getByKey(key);\n        return node;\n    }\n    /**\n   * Returns a list with the NodeInfo objects for the defined range\n   * @param {number} start\n   * @param {number} limit\n   */ getObjectNodes(start = 0, limit) {\n        if (this.type !== 'object') throw new Error(`Unsupported method on non-object ${this.type}`);\n        (0, $3NxB6.assertStartLimit)(start, limit);\n        const nodes = {};\n        return this.getObjectKeys(start, limit).map((key)=>new $04e605f16dc82b7e$export$defd4a491b161b4d(this.ref[key], [\n                ...this.path,\n                key\n            ]));\n    }\n    /**\n   * Returns a list of NodeInfo for the defined range\n   * @param {number} start\n   * @param {number} limit\n   */ getArrayNodes(start = 0, limit) {\n        if (this.type !== 'array') throw new Error(`Unsupported method on non-array ${this.type}`);\n        (0, $3NxB6.assertStartLimit)(start, limit);\n        const elements = limit ? this.ref.slice(start, start + limit) : this.ref.slice(start);\n        return elements.map((ref, i)=>new $04e605f16dc82b7e$export$defd4a491b161b4d(ref, [\n                ...this.path,\n                String(start + i)\n            ]));\n    }\n    /**\n   * Get the natively parsed value\n   */ getValue() {\n        return this.ref;\n    }\n}\nclass $04e605f16dc82b7e$export$ff409fe831d40557 {\n    constructor(data){\n        this.data = data;\n    }\n    getRootNodeInfo() {\n        if (this.data === undefined) return null;\n        return new $04e605f16dc82b7e$export$defd4a491b161b4d(this.data, []);\n    }\n}\n\n});\n\n\nclass $0089ee43e780e197$export$e4cd0dfd45d302cc {\n    constructor(worker){\n        this.worker = worker;\n        this.requestIndex = 0;\n        this.requestCallbacks = {};\n    }\n    initWorker() {\n        return new Promise((resolve, reject)=>{\n            this.worker.onmessage = (msg)=>{\n                const data = msg.data;\n                if (data._init === true) {\n                    this.initialized = true;\n                    resolve(true);\n                    return;\n                }\n                if (data.resultId && this.requestCallbacks[data.resultId]) {\n                    const callb = this.requestCallbacks[data.resultId];\n                    delete this.requestCallbacks[data.resultId];\n                    callb(data);\n                }\n            };\n            this.worker.onerror = (e)=>{\n                if (!this.initialized) reject(e);\n                else console.error('Worker error', e);\n            };\n            this.worker.postMessage({\n                _init: true\n            });\n        });\n    }\n    call(handler, ...args) {\n        return this.callWorker(handler, undefined, ...args);\n    }\n    callWorker(handler, transfers, ...args) {\n        return new Promise((resolve, reject)=>{\n            const resultId = ++this.requestIndex;\n            this.requestCallbacks[resultId] = (data)=>{\n                if (data.error !== undefined) {\n                    reject(data.error);\n                    return;\n                }\n                resolve(data.result);\n            };\n            this.worker.postMessage({\n                handler: handler,\n                args: args,\n                resultId: resultId\n            }, transfers);\n        });\n    }\n    destroy() {\n        this.worker.terminate();\n        this.worker = null;\n        this.requestCallbacks = null;\n    }\n}\nclass $0089ee43e780e197$export$17ddad5eb3af88a1 {\n    constructor(provider){\n        this.provider = provider;\n    }\n    call(handler, ...args) {\n        return this.callWorker(handler, undefined, ...args);\n    }\n    callWorker(handler, transfers, ...args) {\n        return new Promise((resolve)=>{\n            resolve(this.provider[handler].apply(this.provider, args));\n        });\n    }\n    destroy() {\n        this.provider = null;\n    }\n}\n\n\n\nvar $jl3no = parcelRequire(\"jl3no\");\n/* tslint:disable */ function $1f8cf106d30a9c70$export$7767ff246a267146() {\n    const blob = new Blob([\n        \"!function(e,t,r,s,o,n,a,i){var h=\\\"undefined\\\"!=typeof globalThis?globalThis:\\\"undefined\\\"!=typeof self?self:\\\"undefined\\\"!=typeof window?window:\\\"undefined\\\"!=typeof global?global:{},l=\\\"function\\\"==typeof h[s]&&h[s],d=l.i||{},p=l.cache||{},u=\\\"undefined\\\"!=typeof module&&\\\"function\\\"==typeof module.require&&module.require.bind(module);function f(t,r){if(!p[t]){if(!e[t]){if(o[t])return o[t];var n=\\\"function\\\"==typeof h[s]&&h[s];if(!r&&n)return n(t,!0);if(l)return l(t,!0);if(u&&\\\"string\\\"==typeof t)return u(t);var a=Error(\\\"Cannot find module '\\\"+t+\\\"'\\\");throw a.code=\\\"MODULE_NOT_FOUND\\\",a}d.resolve=function(r){var s=e[t][1][r];return null!=s?s:r},d.cache={};var i=p[t]=new f.Module(t);e[t][0].call(i.exports,d,i,i.exports,h)}return p[t].exports;function d(e){var t=d.resolve(e);if(!1===t)return{};if(Array.isArray(t)){var r={__esModule:!0};return t.forEach(function(e){var t=e[0],s=e[1],o=e[2]||e[0],n=f(s);\\\"*\\\"===t?Object.keys(n).forEach(function(e){\\\"default\\\"===e||\\\"__esModule\\\"===e||Object.prototype.hasOwnProperty.call(r,e)||Object.defineProperty(r,e,{enumerable:!0,get:function(){return n[e]}})}):\\\"*\\\"===o?Object.defineProperty(r,t,{enumerable:!0,value:n}):Object.defineProperty(r,t,{enumerable:!0,get:function(){return\\\"default\\\"===o?n.__esModule?n.default:n:n[o]}})}),r}return f(t)}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.require=u,this.exports={}},f.modules=e,f.cache=p,f.parent=l,f.distDir=void 0,f.publicUrl=void 0,f.devServer=void 0,f.i=d,f.register=function(t,r){e[t]=[function(e,t){t.exports=r},{}]},Object.defineProperty(f,\\\"root\\\",{get:function(){return h[s]}}),h[s]=f;for(var c=0;c<t.length;c++)f(t[c]);if(r){var y=f(r);\\\"object\\\"==typeof exports&&\\\"undefined\\\"!=typeof module?module.exports=y:\\\"function\\\"==typeof define&&define.amd&&define(function(){return y})}}({kGz5N:[function(e,t,r,s){var o=e(\\\"../helpers/worker-provider\\\"),n=e(\\\"../big-json-viewer-service\\\");(0,o.initProvider)(new(0,n.BigJsonViewerService))},{\\\"../helpers/worker-provider\\\":\\\"vpIKR\\\",\\\"../big-json-viewer-service\\\":\\\"lsYGb\\\"}],vpIKR:[function(e,t,r,s){var o=e(\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\");function n(e,t=self){t.onmessage=function(r){let s=r.data;if(s._init)return void t.postMessage({_init:!0});if(s.handler&&e[s.handler])try{let r=e[s.handler].apply(e,s.args);s.resultId&&t.postMessage({resultId:s.resultId,result:r})}catch(e){s.resultId&&t.postMessage({resultId:s.resultId,error:e.toString()})}}}o.defineInteropFlag(r),o.export(r,\\\"initProvider\\\",()=>n)},{\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\":\\\"kdXvs\\\"}],kdXvs:[function(e,t,r,s){r.interopDefault=function(e){return e&&e.__esModule?e:{default:e}},r.defineInteropFlag=function(e){Object.defineProperty(e,\\\"__esModule\\\",{value:!0})},r.exportAll=function(e,t){return Object.keys(e).forEach(function(r){\\\"default\\\"===r||\\\"__esModule\\\"===r||Object.prototype.hasOwnProperty.call(t,r)||Object.defineProperty(t,r,{enumerable:!0,get:function(){return e[r]}})}),t},r.export=function(e,t,r){Object.defineProperty(e,t,{enumerable:!0,get:r})}},{}],lsYGb:[function(e,t,r,s){var o=e(\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\");o.defineInteropFlag(r),o.export(r,\\\"BigJsonViewerService\\\",()=>h);var n=e(\\\"./parser/json-node-search\\\"),a=e(\\\"./parser/buffer-json-parser\\\"),i=e(\\\"./parser/js-parser\\\");class h{initWithData(e){return this.rootNode=new(0,a.BufferJsonParser)(e).getRootNodeInfo(),this.getRenderInfo(this.rootNode)}initWithJs(e){return this.rootNode=new(0,i.JsParser)(e).getRootNodeInfo(),this.getRenderInfo(this.rootNode)}getNodes(e,t,r){let s=this.rootNode.getByPath(e);return s&&\\\"object\\\"===s.type?s.getObjectNodes(t,r).map(e=>this.getRenderInfo(e)):s&&\\\"array\\\"===s.type?s.getArrayNodes(t,r).map(e=>this.getRenderInfo(e)):null}getKeyIndex(e,t){let r=this.rootNode.getByPath(e);return r?r.getObjectKeys().indexOf(t):-1}search(e,t){return(0,n.searchJsonNodes)(this.rootNode,e,t)}getRenderInfo(e){let t={type:e.type,length:e.length,path:e.path,openable:this.isOpenableNode(e)};return t.openable||(t.value=e.getValue()),t}isOpenableNode(e){return(\\\"array\\\"===e.type||\\\"object\\\"===e.type)&&!!e.length}}},{\\\"./parser/json-node-search\\\":\\\"bjnFk\\\",\\\"./parser/buffer-json-parser\\\":\\\"aPMcZ\\\",\\\"./parser/js-parser\\\":\\\"6NMJx\\\",\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\":\\\"kdXvs\\\"}],bjnFk:[function(e,t,r,s){var o=e(\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\");function n(e,t,r){(e=a(e)).lastIndex=0;let s=null;for(;null!==(s=e.exec(t));)r(s.index,s[0].length);e.lastIndex=0}function a(e){if(!e.global){let t=\\\"g\\\"+(e.ignoreCase?\\\"i\\\":\\\"\\\")+(e.multiline?\\\"m\\\":\\\"\\\");return new RegExp(e.source,t)}return e}o.defineInteropFlag(r),o.export(r,\\\"searchJsonNodes\\\",()=>function e(t,r,s=\\\"all\\\"){r=a(r);let o=[];return t.path.length&&(\\\"all\\\"===s||\\\"keys\\\"===s)&&n(r,t.path[t.path.length-1],(e,r)=>{o.push({path:t.path,key:e,length:r})}),\\\"object\\\"===t.type?t.getObjectNodes().forEach(t=>{o.push(...e(t,r,s))}):\\\"array\\\"===t.type?t.getArrayNodes().forEach(t=>{o.push(...e(t,r,s))}):(\\\"all\\\"===s||\\\"values\\\"===s)&&n(r,String(t.getValue()),(e,r)=>{o.push({path:t.path,value:e,length:r})}),o}),o.export(r,\\\"forEachMatchFromString\\\",()=>n)},{\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\":\\\"kdXvs\\\"}],aPMcZ:[function(e,t,r,s){var o=e(\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\");o.defineInteropFlag(r),o.export(r,\\\"BufferJsonNodeInfo\\\",()=>d),o.export(r,\\\"BufferJsonParser\\\",()=>p);var n=e(\\\"../helpers/utils\\\");let a=[32,9,10,13],i=\\\"null\\\".split(\\\"\\\").map(e=>e.charCodeAt(0)),h=\\\"true\\\".split(\\\"\\\").map(e=>e.charCodeAt(0)),l=\\\"false\\\".split(\\\"\\\").map(e=>e.charCodeAt(0));class d{constructor(e,t,r){this.path=[],this.parser=e,this.index=t,this.path=r}getObjectKeys(e=0,t){if(\\\"object\\\"!==this.type)throw Error(`Unsupported method on non-object ${this.type}`);(0,n.assertStartLimit)(e,t);let r={path:this.path,objectKeys:[],start:e,limit:t};return this.parser.parseObject(this.index,r),r.objectKeys}getByIndex(e){if(\\\"object\\\"===this.type){let t=this.getObjectNodes(e,1);if(t.length)return t[0]}if(\\\"array\\\"===this.type){let t=this.getArrayNodes(e,1);if(t.length)return t[0]}}getByKey(e){if(\\\"object\\\"===this.type){let t={path:this.path,objectKey:e};return this.parser.parseObject(this.index,t),t.objectNodes?t.objectNodes[0]:void 0}if(\\\"array\\\"===this.type)return this.getByIndex(parseInt(e))}getByPath(e){let t;if(!e)return;if(!e.length)return this;let r=e.slice(),s=this;for(;void 0!==(t=r.shift())&&s;)s=s.getByKey(t);return s}getObjectNodes(e=0,t){if(\\\"object\\\"!==this.type)throw Error(`Unsupported method on non-object ${this.type}`);(0,n.assertStartLimit)(e,t);let r={path:this.path,objectNodes:[],start:e,limit:t};return this.parser.parseObject(this.index,r),r.objectNodes}getArrayNodes(e=0,t){if(\\\"array\\\"!==this.type)throw Error(`Unsupported method on non-array ${this.type}`);(0,n.assertStartLimit)(e,t);let r={path:this.path,arrayNodes:[],start:e,limit:t};return this.parser.parseArray(this.index,r),r.arrayNodes}getValue(){return this.parser.parseNative(this.index,this.index+this.chars)}}class p{constructor(e){if(e instanceof ArrayBuffer)this.data=new Uint16Array(e);else if(\\\"string\\\"==typeof e&&\\\"undefined\\\"!=typeof TextEncoder)this.data=new TextEncoder().encode(e);else if(\\\"string\\\"==typeof e){this.data=new Uint16Array(new ArrayBuffer(2*e.length));for(let t=0;t<e.length;t++)this.data[t]=e.charCodeAt(t)}}getRootNodeInfo(){let e=this.skipIgnored(0),t={path:[],nodeInfo:new d(this,e,[])},r=this.parseValue(e,t,!1);return e===r?null:t.nodeInfo}parseValue(e,t,r=!0){var s,o;let n=this.data[e];if(34===(s=n)||39===s)return this.parseString(e,t);if(45===(o=n)||o>=48&&o<=57)return this.parseNumber(e,t);if(123===n)return this.parseObject(e,t);if(91===n)return this.parseArray(e,t);if(n===h[0])return this.parseToken(e,h,t);if(n===l[0])return this.parseToken(e,l,t);if(n===i[0])return this.parseToken(e,i,t);if(r)throw Error(`parse value unknown token ${u(n)} at ${e}`)}parseObject(e,t){let r=e+1,s=0,o=[],n=[];for(;r<=this.data.length;){var a;if(r===this.data.length)throw Error(\\\"parse object incomplete at end\\\");if(r=this.skipIgnored(r),125===this.data[r]){r++;break}let e=(a=s,!t||t.start&&a<t.start||t.limit&&a>=t.start+t.limit?null:t&&(t.objectKeys||t.objectNodes||void 0!==t.objectKey)?{path:t.path,value:null}:null);if(r=this.parseString(r,e),e&&t&&t.objectKeys&&o.push(e.value),r=this.skipIgnored(r),58!==this.data[r])throw Error(`parse object unexpected token ${u(this.data[r])} at ${r}. Expected :`);r++,r=this.skipIgnored(r);let i=null;if(e&&t&&(t.objectNodes||e.value===t.objectKey)&&(i={path:t.path,nodeInfo:new d(this,r,[...t.path,e.value])}),r=this.parseValue(r,i),r=this.skipIgnored(r),i&&t.objectNodes)n.push(i.nodeInfo);else if(i&&void 0!==t.objectKey){t.objectNodes=[i.nodeInfo];return}if(s++,44===this.data[r])r++;else if(125!==this.data[r])throw Error(`parse object unexpected token ${u(this.data[r])} at ${r}. Expected , or }`)}return t&&t.nodeInfo&&(t.nodeInfo.type=\\\"object\\\",t.nodeInfo.length=s,t.nodeInfo.chars=r-e),t&&t.objectKeys&&(t.objectKeys=o),t&&t.objectNodes&&(t.objectNodes=n),r}parseArray(e,t){let r=e+1,s=0;for(;r<=this.data.length;){var o;if(r===this.data.length)throw Error(\\\"parse array incomplete at end\\\");if(r=this.skipIgnored(r),93===this.data[r]){r++;break}let e=null;if(o=s,!(!t||t.start&&o<t.start||t.limit&&o>=t.start+t.limit)&&t.arrayNodes&&(e={path:t.path,nodeInfo:new d(this,r,[...t.path,s.toString()])}),r=this.parseValue(r,e),e&&t.arrayNodes.push(e.nodeInfo),r=this.skipIgnored(r),s++,44===this.data[r])r++;else if(93!==this.data[r])throw Error(`parse array unexpected token ${u(this.data[r])} at ${r}. Expected , or ]`)}return t&&t.nodeInfo&&(t.nodeInfo.type=\\\"array\\\",t.nodeInfo.length=s,t.nodeInfo.chars=r-e),r}parseString(e,t){let r=e,s=34===this.data[r]?34:39,o=!1,n=0;for(r++;r<=this.data.length;r++){if(r===this.data.length)throw Error(\\\"parse string incomplete at end\\\");if(!o&&this.data[r]===s){r++;break}!(o=92===this.data[r]&&!o)&&n++}return t&&t.nodeInfo&&(t.nodeInfo.type=\\\"string\\\",t.nodeInfo.length=n,t.nodeInfo.chars=r-e),t&&void 0!==t.value&&(t.value=JSON.parse(u(this.data.subarray(e,r)))),r}parseNumber(e,t){let r=e;return 45===this.data[r]&&r++,r=this.parseDigits(r),46===this.data[r]&&(r++,r=this.parseDigits(r)),(69===this.data[r]||101===this.data[r])&&(r++,(43===this.data[r]||45===this.data[r])&&r++,r=this.parseDigits(r)),t&&t.nodeInfo&&(t.nodeInfo.type=\\\"number\\\",t.nodeInfo.chars=r-e),t&&void 0!==t.value&&(t.value=JSON.parse(u(this.data.subarray(e,r)))),r}parseDigits(e){for(;this.data[e]>=48&&this.data[e]<=57;)e++;return e}parseToken(e,t,r){let s=e;for(let e=0;e<t.length;e++){if(this.data[s]!==t[e])throw Error(`Unexpected token ${u(this.data[s])} at ${s}. Expected ${u(t)}`);s++}let o=u(this.data.subarray(e,s));return r&&r.nodeInfo&&(\\\"null\\\"===o?r.nodeInfo.type=\\\"null\\\":r.nodeInfo.type=\\\"boolean\\\",r.nodeInfo.chars=s-e),r&&void 0!==r.value&&(r.value=JSON.parse(o)),s}parseNative(e,t){return JSON.parse(u(this.data.subarray(e,t)))}skipIgnored(e){for(let t=e;t<this.data.length;t++)if(-1===a.indexOf(this.data[t]))return t}}function u(e){return\\\"number\\\"==typeof e&&(e=[e]),String.fromCharCode.apply(null,e)}},{\\\"../helpers/utils\\\":\\\"501Ss\\\",\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\":\\\"kdXvs\\\"}],\\\"501Ss\\\":[function(e,t,r,s){var o=e(\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\");function n(e,t){if(isNaN(e)||e<0)throw Error(`Invalid start ${e}`);if(t&&t<0)throw Error(`Invalid limit ${t}`)}o.defineInteropFlag(r),o.export(r,\\\"assertStartLimit\\\",()=>n)},{\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\":\\\"kdXvs\\\"}],\\\"6NMJx\\\":[function(e,t,r,s){var o=e(\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\");o.defineInteropFlag(r),o.export(r,\\\"JsJsonNodeInfo\\\",()=>a),o.export(r,\\\"JsParser\\\",()=>i);var n=e(\\\"../helpers/utils\\\");class a{constructor(e,t){this.path=[],this.ref=e,this.path=t;const r=typeof e;\\\"undefined\\\"===r&&(this.type=\\\"undefined\\\"),\\\"symbol\\\"===r&&(this.type=\\\"symbol\\\"),\\\"function\\\"===r&&(this.type=\\\"function\\\"),\\\"object\\\"===r&&null===e?this.type=\\\"null\\\":\\\"object\\\"===r&&Array.isArray(e)?this.type=\\\"array\\\":this.type=r,\\\"object\\\"===this.type&&(this.length=Object.keys(e).length),(\\\"array\\\"===this.type||\\\"string\\\"===this.type)&&(this.length=e.length)}getObjectKeys(e=0,t){if(\\\"object\\\"!==this.type)throw Error(`Unsupported method on non-object ${this.type}`);(0,n.assertStartLimit)(e,t);let r=Object.keys(this.ref);return t?r.slice(e,e+t):r.slice(e)}getByIndex(e){if(\\\"object\\\"===this.type){let t=this.getObjectNodes(e,1);if(t.length)return t[0]}if(\\\"array\\\"===this.type){let t=this.getArrayNodes(e,1);if(t.length)return t[0]}}getByKey(e){return\\\"object\\\"===this.type&&this.ref.hasOwnProperty(e)?new a(this.ref[e],[...this.path,e]):\\\"array\\\"===this.type?this.getByIndex(parseInt(e)):void 0}getByPath(e){let t;if(!e)return;if(!e.length)return this;let r=e.slice(),s=this;for(;void 0!==(t=r.shift())&&s;)s=s.getByKey(t);return s}getObjectNodes(e=0,t){if(\\\"object\\\"!==this.type)throw Error(`Unsupported method on non-object ${this.type}`);return(0,n.assertStartLimit)(e,t),this.getObjectKeys(e,t).map(e=>new a(this.ref[e],[...this.path,e]))}getArrayNodes(e=0,t){if(\\\"array\\\"!==this.type)throw Error(`Unsupported method on non-array ${this.type}`);return(0,n.assertStartLimit)(e,t),(t?this.ref.slice(e,e+t):this.ref.slice(e)).map((t,r)=>new a(t,[...this.path,String(e+r)]))}getValue(){return this.ref}}class i{constructor(e){this.data=e}getRootNodeInfo(){return void 0===this.data?null:new a(this.data,[])}}},{\\\"../helpers/utils\\\":\\\"501Ss\\\",\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\":\\\"kdXvs\\\"}]},[\\\"kGz5N\\\"],\\\"kGz5N\\\",\\\"parcelRequire13a7\\\",{});\\n//# sourceMappingURL=big-json-viewer.worker.js.map\\n\"\n    ], {\n        type: 'text/javascript'\n    });\n    const workerUrl = URL.createObjectURL(blob);\n    return new Worker(workerUrl);\n}\n\n\n\nclass $0096928a09a25e8f$export$6efa9165c4ad4d70 {\n    /**\n   * Initialized the viewer with JSON encoded data\n   */ static async fromData(data, options) {\n        const viewer = new $0096928a09a25e8f$export$6efa9165c4ad4d70(options);\n        await viewer.setData(data);\n        return viewer;\n    }\n    /**\n   * Initializes the viewer with a JavaScript object\n   */ static async fromObject(data, options) {\n        const viewer = new $0096928a09a25e8f$export$6efa9165c4ad4d70(options);\n        await viewer.setObject(data);\n        return viewer;\n    }\n    constructor(options){\n        this.options = {\n            objectNodesLimit: 50,\n            arrayNodesLimit: 50,\n            labelAsPath: false,\n            linkLabelCopyPath: 'Copy path',\n            linkLabelExpandAll: 'Expand all',\n            workerPath: null,\n            collapseSameValue: 5\n        };\n        this.currentArea = 'all';\n        this.currentMark = null;\n        if (options) Object.assign(this.options, options);\n    }\n    async getWorkerClient() {\n        if (!this.workerClient) try {\n            const worker = this.options.workerPath ? new Worker(this.options.workerPath) : (0, $1f8cf106d30a9c70$export$7767ff246a267146)();\n            const client = new (0, $0089ee43e780e197$export$e4cd0dfd45d302cc)(worker);\n            await client.initWorker();\n            this.workerClient = client;\n        } catch (e) {\n            console.warn('Could not instantiate Worker ' + this.options.workerPath + ', using mock', e);\n            const serviceModule = (parcelRequire(\"dpnMS\"));\n            const service = new serviceModule.BigJsonViewerService();\n            this.workerClient = new (0, $0089ee43e780e197$export$17ddad5eb3af88a1)(service);\n        }\n        return this.workerClient;\n    }\n    async setData(data) {\n        const client = await this.getWorkerClient();\n        this.rootNode = await client.call('initWithData', data);\n        return this.rootNode;\n    }\n    async setObject(data) {\n        const client = await this.getWorkerClient();\n        this.rootNode = await client.call('initWithJs', data);\n        return this.rootNode;\n    }\n    async getChildNodes(path, start, limit) {\n        const client = await this.getWorkerClient();\n        return client.call('getNodes', path, start, limit);\n    }\n    async getSearchMatches(pattern, searchArea) {\n        const client = await this.getWorkerClient();\n        return await client.call('search', pattern, searchArea);\n    }\n    async getKeyIndex(path, key) {\n        const client = await this.getWorkerClient();\n        return await client.call('getKeyIndex', path, key);\n    }\n    /**\n   * Destroys the viewer and frees resources like the worker\n   */ destroy() {\n        if (this.workerClient) {\n            this.workerClient.destroy();\n            this.workerClient = null;\n        }\n        this.rootElement = null;\n        this.currentPattern = null;\n    }\n    getRootElement() {\n        if (this.rootElement) return this.rootElement;\n        if (this.rootNode) {\n            const nodeElement = this.getNodeElement(this.rootNode);\n            nodeElement.classList.add('json-node-root');\n            this.rootElement = nodeElement;\n            return nodeElement;\n        }\n        return null;\n    }\n    getNodeElement(node) {\n        const element = document.createElement('div');\n        element.classList.add('json-node');\n        element.jsonNode = node;\n        const header = this.getNodeHeader(node);\n        element.headerElement = element.appendChild(header);\n        this.attachInteractivity(element, node);\n        return element;\n    }\n    attachInteractivity(nodeElement, node) {\n        nodeElement.isNodeOpen = ()=>{\n            if (this.isOpenableNode(node)) return nodeElement.headerElement.classList.contains('json-node-open');\n            return false;\n        };\n        nodeElement.openNode = async (dispatchEvent = false)=>{\n            if (this.isOpenableNode(node)) return await this.openNode(nodeElement, dispatchEvent);\n            return false;\n        };\n        nodeElement.closeNode = async (dispatchEvent = false)=>{\n            if (this.isOpenableNode(node)) return this.closeNode(nodeElement, dispatchEvent);\n            return false;\n        };\n        nodeElement.toggleNode = async (dispatchEvent = false)=>{\n            if (nodeElement.isNodeOpen()) return await nodeElement.closeNode(dispatchEvent);\n            else return await nodeElement.openNode(dispatchEvent);\n        };\n        nodeElement.openPath = async (path)=>{\n            if (this.isOpenableNode(node)) return await this.openPath(nodeElement, path, true);\n            return null;\n        };\n        nodeElement.openAll = async (maxDepth = Infinity, paginated = 'first')=>{\n            if (this.isOpenableNode(node)) return await this.openAll(nodeElement, maxDepth, paginated);\n            return 0;\n        };\n        nodeElement.getOpenPaths = (withStubs = true)=>{\n            if (this.isOpenableNode(node)) return this.getOpenPaths(nodeElement, withStubs);\n            return [];\n        };\n    }\n    attachClickToggleListener(anchor) {\n        anchor.addEventListener('click', (e)=>{\n            e.preventDefault();\n            const nodeElement = this.findNodeElement(anchor);\n            if (nodeElement) nodeElement.toggleNode(true);\n        });\n    }\n    isOpenableNode(node) {\n        return (node.type === 'array' || node.type === 'object') && node.length;\n    }\n    closeNode(nodeElement, dispatchEvent = false) {\n        if (!nodeElement.isNodeOpen()) return false;\n        if (nodeElement.childrenElement) {\n            nodeElement.headerElement.classList.remove('json-node-open');\n            nodeElement.removeChild(nodeElement.childrenElement);\n            nodeElement.childrenElement = null;\n            if (dispatchEvent) this.dispatchNodeEvent('closeNode', nodeElement);\n            return true;\n        }\n        return false;\n    }\n    refreshHeaders(nodeElement) {\n        const header = this.getNodeHeader(nodeElement.jsonNode);\n        if (nodeElement.isNodeOpen()) header.classList.add('json-node-open');\n        nodeElement.headerElement.parentElement.replaceChild(header, nodeElement.headerElement);\n        nodeElement.headerElement = header;\n        if (nodeElement.childrenElement) this.getVisibleChildren(nodeElement.childrenElement.children).forEach((element)=>this.refreshHeaders(element));\n    }\n    getHighlightedText(text, pattern) {\n        const fragment = document.createDocumentFragment();\n        if (!pattern) {\n            fragment.appendChild(document.createTextNode(text));\n            return fragment;\n        }\n        let lastIndex = 0;\n        (0, $jl3no.forEachMatchFromString)(pattern, text, (index, length)=>{\n            if (lastIndex < index) fragment.appendChild(document.createTextNode(text.substring(lastIndex, index)));\n            const mark = document.createElement('mark');\n            mark.appendChild(document.createTextNode(text.substr(index, length)));\n            fragment.appendChild(mark);\n            lastIndex = index + length;\n        });\n        if (lastIndex !== text.length) fragment.appendChild(document.createTextNode(text.substring(lastIndex, text.length)));\n        return fragment;\n    }\n    /**\n   * Opens the tree nodes based on a pattern\n   * openLimit is 1 by default, you can provide Infinity for all\n   * searchArea is 'all' by default\n   */ async openBySearch(pattern, openLimit = 1, searchArea = 'all') {\n        const nodeElement = this.rootElement;\n        this.currentPattern = pattern;\n        this.currentArea = searchArea;\n        if (!pattern) {\n            this.closeNode(nodeElement, true);\n            return null;\n        }\n        this.refreshHeaders(nodeElement);\n        const viewer = this;\n        const matches = await this.getSearchMatches(pattern, searchArea);\n        const cursor = {\n            matches: matches,\n            index: 0,\n            async navigateTo (index) {\n                this.index = index;\n                const match = this.matches[index];\n                if (!match) {\n                    console.warn('searchIndex does not exist on ' + this.matches.length, index);\n                    return;\n                }\n                const openedElement = await viewer.openSearchMatch(nodeElement, match);\n                if (openedElement) {\n                    if (openedElement.scrollIntoView) openedElement.scrollIntoView({\n                        block: 'center'\n                    });\n                    if (viewer.currentMark) viewer.currentMark.classList.remove('highlight-active');\n                    viewer.currentMark = viewer.findMarkForMatch(openedElement, match);\n                    if (viewer.currentMark) viewer.currentMark.classList.add('highlight-active');\n                    return true;\n                }\n                return false;\n            },\n            next () {\n                return this.navigateTo(this.index + 1 >= this.matches.length ? 0 : this.index + 1);\n            },\n            previous () {\n                return this.navigateTo(this.index - 1 < 0 ? this.matches.length : this.index - 1);\n            }\n        };\n        const length = Math.min(matches.length, openLimit);\n        for(let i = 0; i < length && i < openLimit; i++)await this.openSearchMatch(nodeElement, matches[i]);\n        this.dispatchNodeEvent('openedNodes', nodeElement);\n        if (matches.length) await cursor.navigateTo(0);\n        return cursor;\n    }\n    findMarkForMatch(nodeElement, match) {\n        let children = null, expectIndex = 0;\n        if (match.key !== undefined) {\n            const label = nodeElement.headerElement.querySelector('.json-node-label');\n            if (label) {\n                children = label.childNodes;\n                expectIndex = match.key;\n            }\n        }\n        if (match.value !== undefined) {\n            const value = nodeElement.headerElement.querySelector('.json-node-value');\n            if (value) {\n                children = value.childNodes;\n                expectIndex = match.value;\n            }\n        }\n        if (children) {\n            let index = nodeElement.jsonNode.type === 'string' ? -1 : 0;\n            for(let i = 0; i < children.length; i++){\n                const cn = children[i];\n                if (cn.nodeType === Node.TEXT_NODE) index += cn.textContent.length;\n                if (cn.nodeType === Node.ELEMENT_NODE && cn.tagName === 'MARK' && expectIndex === index) return cn;\n            }\n        }\n        return null;\n    }\n    async openSearchMatch(nodeElement, match) {\n        if (match.key !== undefined && match.path.length) {\n            if (match.path.length) {\n                const matchNodeElementParent = await this.openPath(nodeElement, match.path.slice(0, -1)); // open the parent\n                if (matchNodeElementParent) return await this.openKey(matchNodeElementParent, match.path[match.path.length - 1]); // ensure the key is visible\n            }\n        } else if (match.value !== undefined) return await this.openPath(nodeElement, match.path);\n        return null;\n    }\n    getOpenPaths(nodeElement, withSubs) {\n        const result = [];\n        if (!nodeElement.isNodeOpen()) return result;\n        const children = nodeElement.childrenElement.children;\n        const nodeElements = this.getVisibleChildren(children);\n        for(let i = 0; i < nodeElements.length; i++){\n            const element = nodeElements[i];\n            if (element.isNodeOpen()) result.push(...this.getOpenPaths(element, withSubs));\n        }\n        const limit = this.getPaginationLimit(nodeElement.jsonNode);\n        // find open stubs\n        if (!result.length && limit) for(let i = 0; i < children.length; i++){\n            const child = children[i];\n            if (child.isNodeOpen() && child.childrenElement && child.childrenElement.children.length) {\n                const first = child.childrenElement.children[0];\n                if (first.jsonNode) result.push(first.jsonNode.path);\n            }\n        }\n        if (!result.length) result.push(nodeElement.jsonNode.path);\n        return result;\n    }\n    async openNode(nodeElement, dispatchEvent = false) {\n        if (nodeElement.isNodeOpen()) return false;\n        nodeElement.headerElement.classList.add('json-node-open');\n        const children = await this.getPaginatedNodeChildren(nodeElement);\n        nodeElement.childrenElement = nodeElement.appendChild(children);\n        if (dispatchEvent) this.dispatchNodeEvent('openNode', nodeElement);\n        return true;\n    }\n    dispatchNodeEvent(type, nodeElement) {\n        let event;\n        if (document.createEvent) {\n            event = document.createEvent('Event');\n            event.initEvent(type, true, false);\n        } else event = new Event(type, {\n            bubbles: true,\n            cancelable: false\n        });\n        nodeElement.dispatchEvent(event);\n    }\n    async openKey(nodeElement, key) {\n        const node = nodeElement.jsonNode;\n        let children = null;\n        let index = -1;\n        if (node.type === 'object') {\n            index = await this.getKeyIndex(node.path, key);\n            if (index === -1) return null;\n            await nodeElement.openNode();\n            // find correct stub in pagination\n            if (node.length > this.options.objectNodesLimit) {\n                const stubIndex = Math.floor(index / this.options.objectNodesLimit);\n                const stub = nodeElement.childrenElement.children[stubIndex];\n                if (stub) {\n                    await stub.openNode();\n                    index -= stubIndex * this.options.objectNodesLimit;\n                    children = stub.childrenElement.children;\n                }\n            } else children = nodeElement.childrenElement.children;\n        }\n        if (node.type === 'array') {\n            index = parseInt(key);\n            if (isNaN(index) || index >= node.length || index < 0) return null;\n            await nodeElement.openNode();\n            // find correct stub in pagination\n            if (node.length > this.options.arrayNodesLimit) {\n                const stubIndex = Math.floor(index / this.options.arrayNodesLimit);\n                const stub = nodeElement.childrenElement.children[stubIndex];\n                if (stub) {\n                    await stub.openNode();\n                    index -= stubIndex * this.options.arrayNodesLimit;\n                    children = stub.childrenElement.children;\n                }\n            } else children = nodeElement.childrenElement.children;\n        }\n        if (children && index >= 0 && index < children.length) {\n            const childNodeElement = children[index];\n            if (!childNodeElement.jsonNode) return null;\n            return childNodeElement;\n        }\n        return null;\n    }\n    async openPath(nodeElement, path, dispatchEvent = false) {\n        if (!path.length) {\n            await this.openNode(nodeElement, dispatchEvent);\n            return nodeElement;\n        }\n        let element = nodeElement;\n        for(let i = 0; i < path.length; i++){\n            if (!element) return null;\n            element = await this.openKey(element, path[i]);\n            if (element) await element.openNode();\n        }\n        if (dispatchEvent) this.dispatchNodeEvent('openedNodes', nodeElement);\n        return element;\n    }\n    async openAll(nodeElement, maxDepth, paginated, dispatchEvent = false) {\n        await nodeElement.openNode();\n        let opened = 1;\n        if (maxDepth <= 1 || !nodeElement.childrenElement) return opened;\n        const newMaxDepth = maxDepth === Infinity ? Infinity : maxDepth - 1;\n        opened += await this.openAllChildren(nodeElement.childrenElement.children, newMaxDepth, paginated);\n        if (dispatchEvent) this.dispatchNodeEvent('openedNodes', nodeElement);\n        return opened;\n    }\n    async openAllChildren(children, maxDepth, paginated) {\n        let opened = 0;\n        for(let i = 0; i < children.length; i++){\n            const child = children[i];\n            if (child.jsonNode) // is a node\n            opened += await child.openAll(maxDepth, paginated);\n            else if (child.openNode) {\n                // is a stub\n                if (paginated === 'none') return opened;\n                await child.openNode();\n                if (child.childrenElement) opened += await this.openAllChildren(child.childrenElement.children, maxDepth, paginated);\n                if (paginated === 'first') return opened;\n            }\n        }\n        return opened;\n    }\n    /**\n   * Returns the pagination limit, if the node should have\n   */ getPaginationLimit(node) {\n        if (node.type === 'array' && node.length > this.options.arrayNodesLimit) return this.options.arrayNodesLimit;\n        if (node.type === 'object' && node.length > this.options.objectNodesLimit) return this.options.objectNodesLimit;\n        return 0;\n    }\n    getVisibleChildren(children) {\n        const result = [];\n        for(let i = 0; i < children.length; i++){\n            const child = children[i];\n            if (child.jsonNode) // is a node\n            result.push(child);\n            else if (child.openNode && child.isNodeOpen() && child.childrenElement) // is a stub\n            result.push(...this.getVisibleChildren(child.childrenElement.children));\n        }\n        return result;\n    }\n    async getPaginatedNodeChildren(nodeElement) {\n        const node = nodeElement.jsonNode;\n        const element = document.createElement('div');\n        element.classList.add('json-node-children');\n        const limit = this.getPaginationLimit(node);\n        if (limit) for(let start = 0; start < node.length; start += limit)element.appendChild(this.getPaginationStub(node, start, limit));\n        else {\n            const nodes = await this.getChildNodes(node.path, 0, limit);\n            this.addChildNodes(nodes, element, node.type === 'array' ? this.options.collapseSameValue : Infinity);\n        }\n        return element;\n    }\n    getPaginationStub(node, start, limit) {\n        const stubElement = document.createElement('div');\n        stubElement.classList.add('json-node-stub');\n        const anchor = document.createElement('a');\n        anchor.href = 'javascript:';\n        anchor.classList.add('json-node-stub-toggler');\n        stubElement.headerElement = anchor;\n        this.generateAccessor(anchor);\n        const end = Math.min(node.length, start + limit) - 1;\n        const label = document.createElement('span');\n        label.classList.add('json-node-label');\n        label.appendChild(document.createTextNode('[' + start + ' ... ' + end + ']'));\n        anchor.appendChild(label);\n        stubElement.appendChild(anchor);\n        anchor.addEventListener('click', async (e)=>{\n            e.preventDefault();\n            if (stubElement.isNodeOpen()) this.closePaginationStub(stubElement, true);\n            else this.openPaginationStub(stubElement, node, await this.getChildNodes(node.path, start, limit), true);\n        });\n        stubElement.isNodeOpen = ()=>{\n            return anchor.classList.contains('json-node-open');\n        };\n        stubElement.openNode = async ()=>{\n            if (!stubElement.isNodeOpen()) {\n                await this.openPaginationStub(stubElement, node, await this.getChildNodes(node.path, start, limit));\n                return true;\n            }\n            return false;\n        };\n        stubElement.closeNode = async ()=>{\n            if (stubElement.isNodeOpen()) {\n                this.closePaginationStub(stubElement);\n                return true;\n            }\n            return false;\n        };\n        stubElement.toggleNode = ()=>{\n            if (stubElement.isNodeOpen()) return stubElement.closeNode();\n            else return stubElement.openNode();\n        };\n        return stubElement;\n    }\n    closePaginationStub(stubElement, dispatchEvent = false) {\n        if (stubElement.childrenElement) {\n            stubElement.headerElement.classList.remove('json-node-open');\n            stubElement.removeChild(stubElement.childrenElement);\n            stubElement.childrenElement = null;\n            if (dispatchEvent) this.dispatchNodeEvent('closeStub', stubElement);\n        }\n    }\n    openPaginationStub(stubElement, node, nodes, dispatchEvent = false) {\n        stubElement.headerElement.classList.add('json-node-open');\n        const children = document.createElement('div');\n        children.classList.add('json-node-children');\n        stubElement.childrenElement = children;\n        this.addChildNodes(nodes, children, node.type === 'array' ? this.options.collapseSameValue : Infinity);\n        stubElement.appendChild(children);\n        if (dispatchEvent) this.dispatchNodeEvent('openStub', stubElement);\n    }\n    addChildNodes(nodes, parent, collapseSameValue) {\n        let lastValue;\n        let sameValueCount = 0;\n        nodes.forEach((node, i)=>{\n            if (node.type !== 'object' && node.type !== 'array' && lastValue === node.value) {\n                sameValueCount++;\n                if (sameValueCount >= collapseSameValue) return;\n            } else if (sameValueCount >= collapseSameValue) {\n                parent.appendChild(this.getCollapseIndicator(sameValueCount));\n                parent.appendChild(this.getNodeElement(nodes[i - 1]));\n                sameValueCount = 0;\n            } else sameValueCount = 0;\n            parent.appendChild(this.getNodeElement(node));\n            lastValue = node.value;\n        });\n        if (sameValueCount >= collapseSameValue) {\n            parent.appendChild(this.getCollapseIndicator(sameValueCount - collapseSameValue));\n            parent.appendChild(this.getNodeElement(nodes[nodes.length - 1]));\n        }\n    }\n    getCollapseIndicator(count) {\n        const element = document.createElement('div');\n        element.classList.add('json-node-collapse');\n        element.appendChild(document.createTextNode('... [' + count + '] ...'));\n        return element;\n    }\n    getNodeHeader(node) {\n        const element = document.createElement('div');\n        element.classList.add('json-node-header');\n        element.classList.add('json-node-' + node.type);\n        const keyHighlightPattern = this.currentArea === 'all' || this.currentArea === 'keys' ? this.currentPattern : null;\n        const valueHighlightPattern = this.currentArea === 'all' || this.currentArea === 'values' ? this.currentPattern : null;\n        if (node.type === 'object' || node.type === 'array') {\n            const anchor = document.createElement('a');\n            anchor.classList.add('json-node-toggler');\n            anchor.href = 'javascript:';\n            if (node.length) {\n                this.attachClickToggleListener(anchor);\n                this.generateAccessor(anchor);\n            }\n            this.generateLabel(anchor, node, keyHighlightPattern);\n            this.generateTypeInfo(anchor, node);\n            element.appendChild(anchor);\n        } else {\n            this.generateLabel(element, node, keyHighlightPattern);\n            this.generateValue(element, node, valueHighlightPattern);\n            this.generateTypeInfo(element, node);\n        }\n        this.generateLinks(element, node);\n        return element;\n    }\n    generateAccessor(parent) {\n        const span = document.createElement('span');\n        span.classList.add('json-node-accessor');\n        parent.appendChild(span);\n    }\n    generateTypeInfo(parent, node) {\n        const typeInfo = document.createElement('span');\n        typeInfo.classList.add('json-node-type');\n        if (node.type === 'object') typeInfo.appendChild(document.createTextNode('Object(' + node.length + ')'));\n        else if (node.type === 'array') typeInfo.appendChild(document.createTextNode('Array[' + node.length + ']'));\n        else typeInfo.appendChild(document.createTextNode(node.type));\n        parent.appendChild(typeInfo);\n    }\n    generateLabel(parent, node, highlightPattern) {\n        if (!node.path.length) return;\n        const label = document.createElement('span');\n        label.classList.add('json-node-label');\n        if (this.options.labelAsPath && node.path.length > 1) {\n            const prefix = document.createElement('span');\n            prefix.classList.add('json-node-label-prefix');\n            prefix.appendChild(document.createTextNode(node.path.slice(0, node.path.length - 1).join('.') + '.'));\n            label.appendChild(prefix);\n        }\n        label.appendChild(this.getHighlightedText(node.path[node.path.length - 1], highlightPattern));\n        parent.appendChild(label);\n        parent.appendChild(document.createTextNode(': '));\n    }\n    generateValue(parent, node, highlightPattern) {\n        const valueElement = document.createElement('span');\n        valueElement.classList.add('json-node-value');\n        valueElement.appendChild(this.getHighlightedText(JSON.stringify(node.value), highlightPattern));\n        parent.appendChild(valueElement);\n    }\n    getLabelNode(label) {\n        if (label instanceof Node) return label;\n        return document.createTextNode(label);\n    }\n    generateLinks(parent, node) {\n        if (this.isOpenableNode(node) && this.options.linkLabelExpandAll) {\n            const link = parent.appendChild(document.createElement('a'));\n            link.classList.add('json-node-link');\n            link.href = 'javascript:';\n            link.appendChild(this.getLabelNode(this.options.linkLabelExpandAll));\n            link.addEventListener('click', (e)=>{\n                e.preventDefault();\n                const nodeElement = this.findNodeElement(parent);\n                if (nodeElement && this.isOpenableNode(nodeElement.jsonNode)) this.openAll(nodeElement, Infinity, 'first', true);\n            });\n        }\n        if (node.path.length && this.options.linkLabelCopyPath) {\n            const link = parent.appendChild(document.createElement('a'));\n            link.classList.add('json-node-link');\n            link.href = 'javascript:';\n            link.appendChild(this.getLabelNode(this.options.linkLabelCopyPath));\n            link.addEventListener('click', (e)=>{\n                e.preventDefault();\n                const input = document.createElement('input');\n                input.type = 'text';\n                input.value = node.path.join('.');\n                const nodeElement = this.findNodeElement(parent);\n                this.dispatchNodeEvent('copyPath', nodeElement);\n                parent.appendChild(input);\n                input.select();\n                try {\n                    if (!document.execCommand('copy')) console.warn('Unable to copy path to clipboard');\n                } catch (e) {\n                    console.error('Unable to copy path to clipboard', e);\n                }\n                parent.removeChild(input);\n            });\n        }\n        if (typeof this.options.addLinksHook === 'function') for (const element of this.options.addLinksHook(node))parent.appendChild(element);\n    }\n    findNodeElement(el) {\n        while(el && !el['jsonNode'])el = el.parentElement;\n        return el;\n    }\n}\n\n\n\n\n\n\nconst $bd79623745b6affc$var$demoData = {\n    simpleData: {\n        element1: 'str',\n        element2: 1234,\n        element3: [\n            23,\n            43,\n            true,\n            false,\n            null,\n            {\n                name: 'special'\n            },\n            {}\n        ],\n        element4: [],\n        element5: 'this should be some long text\\nwith line break',\n        element6: {\n            name: 'Hero',\n            age: 32,\n            birthday: {\n                year: 1986,\n                month: 4,\n                day: 30\n            }\n        },\n        element7: [\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1\n        ]\n    },\n    jsData: {\n        element1: 'str',\n        element2: 1234,\n        element3: [\n            23,\n            43,\n            true,\n            false,\n            null,\n            {\n                name: 'special'\n            },\n            {}\n        ],\n        element4: [],\n        element5: 'this should be some long text\\nwith line break',\n        element6: {\n            name: 'Hero',\n            age: 32,\n            birthday: {\n                year: 1986,\n                month: 4,\n                day: 30\n            }\n        },\n        element7: [\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            1\n        ],\n        element8: {\n            un: undefined,\n            nu: null\n        }\n    },\n    largeData: function() {\n        const list = new Array(Math.floor(Math.random() * 1000));\n        for(let i = 0; i < list.length; i++){\n            list[i] = Math.random();\n            if (list[i] < 0.2) list[i] = 'hey ' + list[i];\n            if (list[i] > 0.8) {\n                list[i] = {};\n                const entries = Math.floor(Math.random() * 1000);\n                for(let j = 0; j < entries; j++)list[i]['entry-' + j] = Math.random();\n            }\n        }\n        return list;\n    }()\n};\nconst $bd79623745b6affc$var$codeElement = document.getElementById('code');\nconst $bd79623745b6affc$var$viewerElement = document.getElementById('viewer');\nconst $bd79623745b6affc$var$pathsElement = document.getElementById('paths');\nconst $bd79623745b6affc$var$copiedElement = document.getElementById('copied');\nconst $bd79623745b6affc$var$searchElement = document.getElementById('search');\nconst $bd79623745b6affc$var$searchInfoElement = document.getElementById('searchInfo');\nlet $bd79623745b6affc$var$viewer = null;\nlet $bd79623745b6affc$var$rootNode = document.getElementById('rootNode');\n$bd79623745b6affc$var$querySelectorArray('[data-load]').forEach((link)=>{\n    const load = link.getAttribute('data-load');\n    if ($bd79623745b6affc$var$demoData[load] && !link.loadListener) {\n        link.loadListener = true;\n        link.addEventListener('click', (e)=>{\n            e.preventDefault();\n            $bd79623745b6affc$var$loadStructureData($bd79623745b6affc$var$demoData[load], load === 'jsData');\n        });\n    }\n});\n$bd79623745b6affc$var$codeElement.addEventListener('input', (e)=>{\n    console.log('show data based on input');\n    $bd79623745b6affc$var$showData($bd79623745b6affc$var$codeElement.value);\n});\n$bd79623745b6affc$var$searchElement.addEventListener('input', async (e)=>{\n    if ($bd79623745b6affc$var$searchElement.value.length >= 2) {\n        const cursor = await $bd79623745b6affc$var$viewer.openBySearch(new RegExp($bd79623745b6affc$var$searchElement.value, 'i'));\n        $bd79623745b6affc$var$searchInfoElement.textContent = cursor.matches.length + ' matches';\n        $bd79623745b6affc$var$searchInfoElement.appendChild(document.createTextNode(' '));\n        const prevBtn = $bd79623745b6affc$var$searchInfoElement.appendChild(document.createElement('a'));\n        prevBtn.href = 'javascript:';\n        prevBtn.addEventListener('click', (e)=>{\n            e.preventDefault();\n            cursor.previous();\n        });\n        prevBtn.textContent = 'Prev';\n        $bd79623745b6affc$var$searchInfoElement.appendChild(document.createTextNode(' '));\n        const nextBtn = $bd79623745b6affc$var$searchInfoElement.appendChild(document.createElement('a'));\n        nextBtn.href = 'javascript:';\n        nextBtn.addEventListener('click', (e)=>{\n            e.preventDefault();\n            cursor.next();\n        });\n        nextBtn.textContent = 'Next';\n    } else {\n        await $bd79623745b6affc$var$rootNode.closeNode();\n        $bd79623745b6affc$var$viewer.openBySearch(null);\n        $bd79623745b6affc$var$searchInfoElement.textContent = '';\n    }\n});\n$bd79623745b6affc$var$loadStructureData($bd79623745b6affc$var$demoData.simpleData);\nasync function $bd79623745b6affc$var$loadStructureData(structure, jsData = false) {\n    if (jsData) {\n        $bd79623745b6affc$var$codeElement.style.display = 'none';\n        await $bd79623745b6affc$var$showData(structure, jsData);\n    } else {\n        const text = JSON.stringify(structure, null, 2);\n        $bd79623745b6affc$var$codeElement.style.display = '';\n        $bd79623745b6affc$var$codeElement.value = text;\n        await $bd79623745b6affc$var$showData(text, jsData);\n    }\n    $bd79623745b6affc$var$showPaths();\n}\nasync function $bd79623745b6affc$var$showData(data, jsData = false) {\n    const index = 'showDataIndex' in $bd79623745b6affc$var$viewerElement ? ++$bd79623745b6affc$var$viewerElement['showDataIndex'] : $bd79623745b6affc$var$viewerElement['showDataIndex'] = 0;\n    if ($bd79623745b6affc$var$viewerElement.children.length) $bd79623745b6affc$var$viewerElement.removeChild($bd79623745b6affc$var$viewerElement.children[0]);\n    if ($bd79623745b6affc$var$viewer) $bd79623745b6affc$var$viewer.destroy();\n    try {\n        let _viewer;\n        if (jsData) _viewer = await (0, $0096928a09a25e8f$export$6efa9165c4ad4d70).fromObject(data);\n        else _viewer = await (0, $0096928a09a25e8f$export$6efa9165c4ad4d70).fromData(data);\n        if ($bd79623745b6affc$var$viewerElement['showDataIndex'] !== index) {\n            _viewer.destroy();\n            return;\n        }\n        $bd79623745b6affc$var$viewer = _viewer;\n        $bd79623745b6affc$var$rootNode = $bd79623745b6affc$var$viewer.getRootElement();\n        $bd79623745b6affc$var$rootNode.id = 'rootNode';\n        $bd79623745b6affc$var$viewerElement.appendChild($bd79623745b6affc$var$rootNode);\n        await $bd79623745b6affc$var$rootNode.openAll(1);\n        $bd79623745b6affc$var$setupRootNode();\n    } catch (e) {\n        console.error('BigJsonViewer error', e);\n        const errEl = document.createElement('div');\n        errEl.classList.add('alert', 'alert-danger');\n        errEl.appendChild(document.createTextNode(e.toString()));\n        $bd79623745b6affc$var$viewerElement.appendChild(errEl);\n    }\n}\nfunction $bd79623745b6affc$var$setupRootNode() {\n    const listener = (e)=>{\n        console.log('event', e.type);\n        $bd79623745b6affc$var$showPaths();\n    };\n    $bd79623745b6affc$var$rootNode.addEventListener('openNode', listener);\n    $bd79623745b6affc$var$rootNode.addEventListener('closeNode', listener);\n    $bd79623745b6affc$var$rootNode.addEventListener('openedNodes', listener);\n    $bd79623745b6affc$var$rootNode.addEventListener('openStub', listener);\n    $bd79623745b6affc$var$rootNode.addEventListener('closeStub', listener);\n    $bd79623745b6affc$var$rootNode.addEventListener('copyPath', (e)=>{\n        const node = e.target;\n        $bd79623745b6affc$var$copiedElement.value = node.jsonNode.path.join('.');\n    });\n}\nfunction $bd79623745b6affc$var$showPaths() {\n    if (!$bd79623745b6affc$var$rootNode || !$bd79623745b6affc$var$rootNode.getOpenPaths) return;\n    $bd79623745b6affc$var$pathsElement.value = $bd79623745b6affc$var$rootNode.getOpenPaths().map((path)=>path.join('.')).join('\\n');\n}\nfunction $bd79623745b6affc$var$querySelectorArray(selector) {\n    const list = document.querySelectorAll(selector);\n    const result = [];\n    for(let i = 0; i < list.length; i++)result.push(list[i]);\n    return result;\n}\n\n\n//# sourceMappingURL=docs-src.36c6ce0c.js.map\n","import { searchJsonNodes } from './parser/json-node-search';\nimport {\n  BigJsonViewerNode,\n  TreeSearchAreaOption,\n  TreeSearchMatch\n} from './model/big-json-viewer.model';\nimport { BufferJsonParser } from './parser/buffer-json-parser';\nimport { JsonNodeInfo } from './parser/json-node-info';\nimport { JsParser } from './parser/js-parser';\n\nexport class BigJsonViewerService {\n  rootNode: JsonNodeInfo;\n\n  initWithData(data: ArrayBuffer | string): BigJsonViewerNode {\n    this.rootNode = new BufferJsonParser(data).getRootNodeInfo();\n\n    return this.getRenderInfo(this.rootNode);\n  }\n\n  initWithJs(data: any): BigJsonViewerNode {\n    this.rootNode = new JsParser(data).getRootNodeInfo();\n\n    return this.getRenderInfo(this.rootNode);\n  }\n\n  getNodes(path: string[], start: number, limit: number): BigJsonViewerNode[] {\n    const node = this.rootNode.getByPath(path);\n    if (node && node.type === 'object') {\n      return node.getObjectNodes(start, limit).map(n => this.getRenderInfo(n));\n    }\n    if (node && node.type === 'array') {\n      return node.getArrayNodes(start, limit).map(n => this.getRenderInfo(n));\n    }\n    return null;\n  }\n\n  getKeyIndex(path: string[], key: string): number {\n    const node = this.rootNode.getByPath(path);\n    if (!node) {\n      return -1;\n    }\n    const keys = node.getObjectKeys();\n    return keys.indexOf(key);\n  }\n\n  search(pattern: RegExp, searchArea: TreeSearchAreaOption): TreeSearchMatch[] {\n    return searchJsonNodes(this.rootNode, pattern, searchArea);\n  }\n\n  protected getRenderInfo(node: JsonNodeInfo): BigJsonViewerNode {\n    const info: BigJsonViewerNode = {\n      type: node.type,\n      length: node.length,\n      path: node.path,\n      openable: this.isOpenableNode(node)\n    };\n    if (!info.openable) {\n      info.value = node.getValue();\n    }\n    return info;\n  }\n\n  protected isOpenableNode(node: JsonNodeInfo): boolean {\n    return (node.type === 'array' || node.type === 'object') && !!node.length;\n  }\n}\n","import { JsonNodeInfo } from './json-node-info';\nimport {\n  TreeSearchAreaOption,\n  TreeSearchMatch\n} from '../model/big-json-viewer.model';\n\n// search only in values\n\nexport function searchJsonNodes(\n  node: JsonNodeInfo,\n  pattern: RegExp,\n  searchArea: TreeSearchAreaOption = 'all'\n): TreeSearchMatch[] {\n  pattern = ensureGlobal(pattern);\n  const results: TreeSearchMatch[] = [];\n  if (node.path.length && (searchArea === 'all' || searchArea === 'keys')) {\n    forEachMatchFromString(\n      pattern,\n      node.path[node.path.length - 1],\n      (index, length) => {\n        results.push({ path: node.path, key: index, length: length });\n      }\n    );\n  }\n  if (node.type === 'object') {\n    node.getObjectNodes().forEach(subNode => {\n      results.push(...searchJsonNodes(subNode, pattern, searchArea));\n    });\n  } else if (node.type === 'array') {\n    node.getArrayNodes().forEach(subNode => {\n      results.push(...searchJsonNodes(subNode, pattern, searchArea));\n    });\n  } else if (searchArea === 'all' || searchArea === 'values') {\n    forEachMatchFromString(\n      pattern,\n      String(node.getValue()),\n      (index, length) => {\n        results.push({ path: node.path, value: index, length: length });\n      }\n    );\n  }\n\n  return results;\n}\n\nexport function forEachMatchFromString(\n  pattern: RegExp,\n  subject: string,\n  callback: (i: number, length: number) => void\n) {\n  pattern = ensureGlobal(pattern);\n  pattern.lastIndex = 0;\n  let match = null;\n  while ((match = pattern.exec(subject)) !== null) {\n    callback(match.index, match[0].length);\n  }\n  pattern.lastIndex = 0;\n}\n\nfunction ensureGlobal(pattern: RegExp): RegExp {\n  if (!pattern.global) {\n    const flags =\n      'g' + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '');\n    return new RegExp(pattern.source, flags);\n  }\n  return pattern;\n}\n","import { JsonNodeInfo, NodeType } from './json-node-info';\nimport { assertStartLimit } from '../helpers/utils';\n\nconst BRACE_START = '{'.charCodeAt(0);\nconst BRACE_END = '}'.charCodeAt(0);\nconst BRACKET_START = '['.charCodeAt(0);\nconst BRACKET_END = ']'.charCodeAt(0);\nconst COLON = ':'.charCodeAt(0);\nconst COMMA = ','.charCodeAt(0);\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0);\nconst SINGLE_QUOTE = \"'\".charCodeAt(0);\nconst SPACE = ' '.charCodeAt(0);\nconst TAB = '\\t'.charCodeAt(0);\nconst NEWLINE = '\\n'.charCodeAt(0);\nconst BACKSPACE = '\\b'.charCodeAt(0);\nconst CARRIAGE_RETURN = '\\r'.charCodeAt(0);\nconst FORM_FEED = '\\f'.charCodeAt(0);\nconst BACK_SLASH = '\\\\'.charCodeAt(0);\nconst FORWARD_SLASH = '/'.charCodeAt(0);\nconst MINUS = '-'.charCodeAt(0);\nconst PLUS = '+'.charCodeAt(0);\nconst DOT = '.'.charCodeAt(0);\nconst CHAR_E_LOW = 'e'.charCodeAt(0);\nconst CHAR_E_HIGH = 'E'.charCodeAt(0);\nconst DIGIT_0 = '0'.charCodeAt(0);\nconst DIGIT_9 = '9'.charCodeAt(0);\n\nconst IGNORED = [SPACE, TAB, NEWLINE, CARRIAGE_RETURN];\n\nconst NULL = 'null'.split('').map(d => d.charCodeAt(0));\nconst TRUE = 'true'.split('').map(d => d.charCodeAt(0));\nconst FALSE = 'false'.split('').map(d => d.charCodeAt(0));\n\nexport interface ParseContext {\n  path: string[];\n  start?: number;\n  limit?: number;\n  objectKey?: string;\n  objectKeys?: string[]; // truthy if keys should be resolved\n  objectNodes?: BufferJsonNodeInfo[]; // truthy if nodes should be resolved\n  arrayNodes?: BufferJsonNodeInfo[]; // truthy if nodes should be resolved\n  value?: string | number | boolean; // truthy if value should be resolved\n  nodeInfo?: BufferJsonNodeInfo; // truthy if node info should be filled\n}\n\nexport class BufferJsonNodeInfo implements JsonNodeInfo {\n  public type: NodeType;\n  public path: string[] = [];\n  public length?: number; // in case of array, object, string\n  public chars: number;\n  private parser: BufferJsonParser;\n  private index;\n\n  constructor(parser: BufferJsonParser, index: number, path: string[]) {\n    this.parser = parser;\n    this.index = index;\n    this.path = path;\n  }\n\n  /**\n   * Returns the list of keys in case of an object for the defined range\n   * @param {number} start\n   * @param {number} limit\n   */\n  public getObjectKeys(start = 0, limit?: number): string[] {\n    if (this.type !== 'object') {\n      throw new Error(`Unsupported method on non-object ${this.type}`);\n    }\n    assertStartLimit(start, limit);\n    const ctx: ParseContext = {\n      path: this.path,\n      objectKeys: [],\n      start: start,\n      limit: limit\n    };\n    this.parser.parseObject(this.index, ctx);\n    return ctx.objectKeys;\n  }\n\n  /**\n   * Return the NodeInfo at the defined position.\n   * Use the index from getObjectKeys\n   * @param index\n   */\n  public getByIndex(index: number): BufferJsonNodeInfo {\n    if (this.type === 'object') {\n      const nodes = this.getObjectNodes(index, 1);\n      if (nodes.length) {\n        return nodes[0];\n      }\n    }\n    if (this.type === 'array') {\n      const nodes = this.getArrayNodes(index, 1);\n      if (nodes.length) {\n        return nodes[0];\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Return the NodeInfo for the specified key\n   * Use the index from getObjectKeys\n   * @param key\n   */\n  public getByKey(key: string): BufferJsonNodeInfo {\n    if (this.type === 'object') {\n      const ctx: ParseContext = {\n        path: this.path,\n        objectKey: key\n      };\n      this.parser.parseObject(this.index, ctx);\n      return ctx.objectNodes ? ctx.objectNodes[0] : undefined;\n    }\n    if (this.type === 'array') {\n      return this.getByIndex(parseInt(key));\n    }\n    return undefined;\n  }\n\n  /**\n   * Find the information for a given path\n   * @param {string[]} path\n   */\n  public getByPath(path: string[]): BufferJsonNodeInfo {\n    if (!path) {\n      return undefined;\n    }\n    if (!path.length) {\n      return this;\n    }\n    const p = path.slice();\n    let key: string;\n    let node: BufferJsonNodeInfo = this;\n    while ((key = p.shift()) !== undefined && node) {\n      node = node.getByKey(key);\n    }\n    return node;\n  }\n\n  /**\n   * Returns a list with the NodeInfo objects for the defined range\n   * @param {number} start\n   * @param {number} limit\n   */\n  public getObjectNodes(start = 0, limit?: number): BufferJsonNodeInfo[] {\n    if (this.type !== 'object') {\n      throw new Error(`Unsupported method on non-object ${this.type}`);\n    }\n    assertStartLimit(start, limit);\n    const ctx: ParseContext = {\n      path: this.path,\n      objectNodes: [],\n      start: start,\n      limit: limit\n    };\n    this.parser.parseObject(this.index, ctx);\n    return ctx.objectNodes;\n  }\n\n  /**\n   * Returns a list of NodeInfo for the defined range\n   * @param {number} start\n   * @param {number} limit\n   */\n  public getArrayNodes(start = 0, limit?: number): BufferJsonNodeInfo[] {\n    if (this.type !== 'array') {\n      throw new Error(`Unsupported method on non-array ${this.type}`);\n    }\n    assertStartLimit(start, limit);\n    const ctx: ParseContext = {\n      path: this.path,\n      arrayNodes: [],\n      start: start,\n      limit: limit\n    };\n    this.parser.parseArray(this.index, ctx);\n    return ctx.arrayNodes;\n  }\n\n  /**\n   * Get the natively parsed value\n   */\n  public getValue(): any {\n    return this.parser.parseNative(this.index, this.index + this.chars);\n  }\n}\n\ndeclare const TextEncoder;\n\n/**\n * Parses meta data about a JSON structure in an ArrayBuffer.\n */\nexport class BufferJsonParser {\n  data: Uint16Array;\n\n  constructor(data: ArrayBuffer | string) {\n    if (data instanceof ArrayBuffer) {\n      this.data = new Uint16Array(data);\n    } else if (typeof data === 'string' && typeof TextEncoder !== 'undefined') {\n      this.data = new TextEncoder().encode(data);\n    } else if (typeof data === 'string') {\n      this.data = new Uint16Array(new ArrayBuffer(data.length * 2));\n      for (let i = 0; i < data.length; i++) {\n        this.data[i] = data.charCodeAt(i);\n      }\n    }\n  }\n\n  getRootNodeInfo(): BufferJsonNodeInfo {\n    let start = this.skipIgnored(0);\n\n    const ctx: ParseContext = {\n      path: [],\n      nodeInfo: new BufferJsonNodeInfo(this, start, [])\n    };\n\n    const end = this.parseValue(start, ctx, false);\n    if (start === end) {\n      return null;\n    }\n    return ctx.nodeInfo;\n  }\n\n  parseValue(start: number, ctx?: ParseContext, throwUnknown = true): number {\n    const char = this.data[start];\n    if (isString(char)) {\n      return this.parseString(start, ctx);\n    }\n    if (isNumber(char)) {\n      return this.parseNumber(start, ctx);\n    }\n    if (char === BRACE_START) {\n      return this.parseObject(start, ctx);\n    }\n    if (char === BRACKET_START) {\n      return this.parseArray(start, ctx);\n    }\n    if (char === TRUE[0]) {\n      return this.parseToken(start, TRUE, ctx);\n    }\n    if (char === FALSE[0]) {\n      return this.parseToken(start, FALSE, ctx);\n    }\n    if (char === NULL[0]) {\n      return this.parseToken(start, NULL, ctx);\n    }\n\n    if (throwUnknown) {\n      throw new Error(\n        `parse value unknown token ${bufToString(char)} at ${start}`\n      );\n    }\n\n    function isString(char) {\n      return char === DOUBLE_QUOTE || char === SINGLE_QUOTE;\n    }\n\n    function isNumber(char) {\n      return char === MINUS || (char >= DIGIT_0 && char <= DIGIT_9);\n    }\n  }\n\n  parseObject(start: number, ctx?: ParseContext): number {\n    let index = start + 1; // skip the start brace\n\n    let length = 0;\n    const keys = [];\n    const nodes = [];\n\n    while (index <= this.data.length) {\n      if (index === this.data.length) {\n        throw new Error(`parse object incomplete at end`);\n      }\n      index = this.skipIgnored(index);\n      if (this.data[index] === BRACE_END) {\n        index++;\n        break;\n      }\n      const keyCtx = getKeyContext(length);\n      index = this.parseString(index, keyCtx);\n\n      if (keyCtx && ctx && ctx.objectKeys) {\n        keys.push(keyCtx.value);\n      }\n\n      index = this.skipIgnored(index);\n      if (this.data[index] !== COLON) {\n        throw new Error(\n          `parse object unexpected token ${bufToString(\n            this.data[index]\n          )} at ${index}. Expected :`\n        );\n      } else {\n        index++;\n      }\n\n      index = this.skipIgnored(index);\n\n      let valueCtx: ParseContext = null;\n      if (\n        keyCtx &&\n        ctx &&\n        (ctx.objectNodes || keyCtx.value === ctx.objectKey)\n      ) {\n        valueCtx = {\n          path: ctx.path,\n          nodeInfo: new BufferJsonNodeInfo(this, index, [\n            ...ctx.path,\n            keyCtx.value as string\n          ])\n        };\n      }\n\n      index = this.parseValue(index, valueCtx);\n      index = this.skipIgnored(index);\n\n      if (valueCtx && ctx.objectNodes) {\n        nodes.push(valueCtx.nodeInfo);\n      } else if (valueCtx && ctx.objectKey !== undefined) {\n        ctx.objectNodes = [valueCtx.nodeInfo];\n        return;\n      }\n\n      length++;\n\n      if (this.data[index] === COMMA) {\n        index++;\n      } else if (this.data[index] !== BRACE_END) {\n        throw new Error(\n          `parse object unexpected token ${bufToString(\n            this.data[index]\n          )} at ${index}. Expected , or }`\n        );\n      }\n    }\n\n    if (ctx && ctx.nodeInfo) {\n      ctx.nodeInfo.type = 'object';\n      ctx.nodeInfo.length = length;\n      ctx.nodeInfo.chars = index - start;\n    }\n    if (ctx && ctx.objectKeys) {\n      ctx.objectKeys = keys;\n    }\n    if (ctx && ctx.objectNodes) {\n      ctx.objectNodes = nodes;\n    }\n\n    function getKeyContext(keyIndex): ParseContext {\n      if (\n        !ctx ||\n        (ctx.start && keyIndex < ctx.start) ||\n        (ctx.limit && keyIndex >= ctx.start + ctx.limit)\n      ) {\n        return null;\n      }\n      if (\n        ctx &&\n        (ctx.objectKeys || ctx.objectNodes || ctx.objectKey !== undefined)\n      ) {\n        return {\n          path: ctx.path,\n          value: null\n        };\n      }\n      return null;\n    }\n\n    return index;\n  }\n\n  parseArray(start: number, ctx?: ParseContext): number {\n    let index = start + 1; // skip the start bracket\n    let length = 0;\n    while (index <= this.data.length) {\n      if (index === this.data.length) {\n        throw new Error(`parse array incomplete at end`);\n      }\n      index = this.skipIgnored(index);\n      if (this.data[index] === BRACKET_END) {\n        index++;\n        break;\n      }\n\n      let valueCtx: ParseContext = null;\n      if (isInRange(length) && ctx.arrayNodes) {\n        valueCtx = {\n          path: ctx.path,\n          nodeInfo: new BufferJsonNodeInfo(this, index, [\n            ...ctx.path,\n            length.toString()\n          ])\n        };\n      }\n\n      index = this.parseValue(index, valueCtx);\n\n      if (valueCtx) {\n        ctx.arrayNodes.push(valueCtx.nodeInfo);\n      }\n\n      index = this.skipIgnored(index);\n\n      length++;\n\n      if (this.data[index] === COMMA) {\n        index++;\n      } else if (this.data[index] !== BRACKET_END) {\n        throw new Error(\n          `parse array unexpected token ${bufToString(\n            this.data[index]\n          )} at ${index}. Expected , or ]`\n        );\n      }\n    }\n\n    if (ctx && ctx.nodeInfo) {\n      ctx.nodeInfo.type = 'array';\n      ctx.nodeInfo.length = length;\n      ctx.nodeInfo.chars = index - start;\n    }\n\n    function isInRange(keyIndex): boolean {\n      return !(\n        !ctx ||\n        (ctx.start && keyIndex < ctx.start) ||\n        (ctx.limit && keyIndex >= ctx.start + ctx.limit)\n      );\n    }\n\n    return index;\n  }\n\n  parseString(start: number, ctx?: ParseContext): number {\n    let index = start;\n    const expect =\n      this.data[index] === DOUBLE_QUOTE ? DOUBLE_QUOTE : SINGLE_QUOTE;\n    let esc = false,\n      length = 0;\n    for (index++; index <= this.data.length; index++) {\n      if (index === this.data.length) {\n        throw new Error(`parse string incomplete at end`);\n      }\n      if (!esc && this.data[index] === expect) {\n        index++;\n        break;\n      }\n      if (this.data[index] === BACK_SLASH) {\n        esc = !esc;\n      } else {\n        esc = false;\n      }\n      if (!esc) {\n        length++;\n      }\n    }\n    if (ctx && ctx.nodeInfo) {\n      ctx.nodeInfo.type = 'string';\n      ctx.nodeInfo.length = length;\n      ctx.nodeInfo.chars = index - start;\n    }\n    if (ctx && ctx.value !== undefined) {\n      ctx.value = JSON.parse(bufToString(this.data.subarray(start, index)));\n    }\n    return index;\n  }\n\n  parseNumber(start: number, ctx?: ParseContext): number {\n    let i = start;\n    if (this.data[i] === MINUS) {\n      i++;\n    }\n    i = this.parseDigits(i);\n    if (this.data[i] === DOT) {\n      i++;\n      i = this.parseDigits(i);\n    }\n    if (this.data[i] === CHAR_E_HIGH || this.data[i] === CHAR_E_LOW) {\n      i++;\n      if (this.data[i] === PLUS || this.data[i] === MINUS) {\n        i++;\n      }\n      i = this.parseDigits(i);\n    }\n    if (ctx && ctx.nodeInfo) {\n      ctx.nodeInfo.type = 'number';\n      ctx.nodeInfo.chars = i - start;\n    }\n    if (ctx && ctx.value !== undefined) {\n      ctx.value = JSON.parse(bufToString(this.data.subarray(start, i)));\n    }\n    return i;\n  }\n\n  private parseDigits(start: number): number {\n    while (this.data[start] >= DIGIT_0 && this.data[start] <= DIGIT_9) {\n      start++;\n    }\n    return start;\n  }\n\n  parseToken(start, chars, ctx?: ParseContext): number {\n    let index = start;\n    for (let i = 0; i < chars.length; i++) {\n      if (this.data[index] !== chars[i]) {\n        throw new Error(\n          `Unexpected token ${bufToString(\n            this.data[index]\n          )} at ${index}. Expected ${bufToString(chars)}`\n        );\n      }\n      index++;\n    }\n    const token = bufToString(this.data.subarray(start, index));\n    if (ctx && ctx.nodeInfo) {\n      if (token === 'null') {\n        ctx.nodeInfo.type = 'null';\n      } else {\n        ctx.nodeInfo.type = 'boolean';\n      }\n      ctx.nodeInfo.chars = index - start;\n    }\n    if (ctx && ctx.value !== undefined) {\n      ctx.value = JSON.parse(token);\n    }\n    return index;\n  }\n\n  parseNative(start, end) {\n    return JSON.parse(bufToString(this.data.subarray(start, end)));\n  }\n\n  private skipIgnored(start: number) {\n    for (let i = start; i < this.data.length; i++) {\n      if (IGNORED.indexOf(this.data[i]) !== -1) {\n        continue;\n      }\n      return i;\n    }\n  }\n}\n\nfunction bufToString(buf: number | number[] | Uint16Array) {\n  if (typeof buf === 'number') {\n    buf = [buf];\n  }\n  return String.fromCharCode.apply(null, buf);\n}\n","export function assertStartLimit(start, limit) {\n  if (isNaN(start) || start < 0) {\n    throw new Error(`Invalid start ${start}`);\n  }\n  if (limit && limit < 0) {\n    throw new Error(`Invalid limit ${limit}`);\n  }\n}\n","import { JsonNodeInfo, NodeType } from './json-node-info';\nimport { assertStartLimit } from '../helpers/utils';\n\nexport class JsJsonNodeInfo implements JsonNodeInfo {\n  public type: NodeType;\n  public path: string[] = [];\n  public length?: number; // in case of array, object, string\n  private readonly ref: any;\n\n  constructor(ref: any, path: string[]) {\n    this.ref = ref;\n    this.path = path;\n    const jsType = typeof ref;\n    if (jsType === 'undefined') {\n      this.type = 'undefined';\n    }\n    if (jsType === 'symbol') {\n      this.type = 'symbol';\n    }\n    if (jsType === 'function') {\n      this.type = 'function';\n    }\n    if (jsType === 'object' && ref === null) {\n      this.type = 'null';\n    } else if (jsType === 'object' && Array.isArray(ref)) {\n      this.type = 'array';\n    } else {\n      this.type = jsType;\n    }\n\n    if (this.type === 'object') {\n      this.length = Object.keys(ref).length;\n    }\n    if (this.type === 'array' || this.type === 'string') {\n      this.length = ref.length;\n    }\n  }\n\n  /**\n   * Returns the list of keys in case of an object for the defined range\n   * @param {number} start\n   * @param {number} limit\n   */\n  public getObjectKeys(start = 0, limit?: number): string[] {\n    if (this.type !== 'object') {\n      throw new Error(`Unsupported method on non-object ${this.type}`);\n    }\n    assertStartLimit(start, limit);\n    const keys = Object.keys(this.ref);\n    if (limit) {\n      return keys.slice(start, start + limit);\n    }\n    return keys.slice(start);\n  }\n\n  /**\n   * Return the NodeInfo at the defined position.\n   * Use the index from getObjectKeys\n   * @param index\n   */\n  public getByIndex(index: number): JsJsonNodeInfo {\n    if (this.type === 'object') {\n      const nodes = this.getObjectNodes(index, 1);\n      if (nodes.length) {\n        return nodes[0];\n      }\n    }\n    if (this.type === 'array') {\n      const nodes = this.getArrayNodes(index, 1);\n      if (nodes.length) {\n        return nodes[0];\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Return the NodeInfo for the specified key\n   * Use the index from getObjectKeys\n   * @param key\n   */\n  public getByKey(key: string): JsJsonNodeInfo {\n    if (this.type === 'object' && this.ref.hasOwnProperty(key)) {\n      return new JsJsonNodeInfo(this.ref[key], [...this.path, key]);\n    }\n    if (this.type === 'array') {\n      return this.getByIndex(parseInt(key));\n    }\n    return undefined;\n  }\n\n  /**\n   * Find the information for a given path\n   * @param {string[]} path\n   */\n  public getByPath(path: string[]): JsJsonNodeInfo {\n    if (!path) {\n      return undefined;\n    }\n    if (!path.length) {\n      return this;\n    }\n    const p = path.slice();\n    let key: string;\n    let node: JsJsonNodeInfo = this;\n    while ((key = p.shift()) !== undefined && node) {\n      node = node.getByKey(key);\n    }\n    return node;\n  }\n\n  /**\n   * Returns a list with the NodeInfo objects for the defined range\n   * @param {number} start\n   * @param {number} limit\n   */\n  public getObjectNodes(start = 0, limit?: number): JsJsonNodeInfo[] {\n    if (this.type !== 'object') {\n      throw new Error(`Unsupported method on non-object ${this.type}`);\n    }\n    assertStartLimit(start, limit);\n    const nodes = {};\n    return this.getObjectKeys(start, limit).map(\n      key => new JsJsonNodeInfo(this.ref[key], [...this.path, key])\n    );\n  }\n\n  /**\n   * Returns a list of NodeInfo for the defined range\n   * @param {number} start\n   * @param {number} limit\n   */\n  public getArrayNodes(start = 0, limit?: number): JsJsonNodeInfo[] {\n    if (this.type !== 'array') {\n      throw new Error(`Unsupported method on non-array ${this.type}`);\n    }\n    assertStartLimit(start, limit);\n    const elements = limit\n      ? this.ref.slice(start, start + limit)\n      : this.ref.slice(start);\n    return elements.map(\n      (ref, i) => new JsJsonNodeInfo(ref, [...this.path, String(start + i)])\n    );\n  }\n\n  /**\n   * Get the natively parsed value\n   */\n  public getValue(): any {\n    return this.ref;\n  }\n}\n\nexport class JsParser {\n  data: any;\n\n  constructor(data: any) {\n    this.data = data;\n  }\n\n  getRootNodeInfo(): JsJsonNodeInfo {\n    if (this.data === undefined) {\n      return null;\n    }\n    return new JsJsonNodeInfo(this.data, []);\n  }\n}\n","import { BigJsonViewerDom, JsonNodeElement } from '../src';\n\nconst demoData = {\n  simpleData: {\n    element1: 'str',\n    element2: 1234,\n    element3: [23, 43, true, false, null, { name: 'special' }, {}],\n    element4: [],\n    element5: 'this should be some long text\\nwith line break',\n    element6: {\n      name: 'Hero',\n      age: 32,\n      birthday: { year: 1986, month: 4, day: 30 }\n    },\n    element7: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n  },\n  jsData: {\n    element1: 'str',\n    element2: 1234,\n    element3: [23, 43, true, false, null, { name: 'special' }, {}],\n    element4: [],\n    element5: 'this should be some long text\\nwith line break',\n    element6: {\n      name: 'Hero',\n      age: 32,\n      birthday: { year: 1986, month: 4, day: 30 }\n    },\n    element7: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    element8: { un: undefined, nu: null }\n  },\n  largeData: (function() {\n    const list = new Array(Math.floor(Math.random() * 1000));\n    for (let i = 0; i < list.length; i++) {\n      list[i] = Math.random();\n      if (list[i] < 0.2) {\n        list[i] = 'hey ' + list[i];\n      }\n      if (list[i] > 0.8) {\n        list[i] = {};\n        const entries = Math.floor(Math.random() * 1000);\n        for (let j = 0; j < entries; j++) {\n          list[i]['entry-' + j] = Math.random();\n        }\n      }\n    }\n    return list;\n  })()\n};\n\nconst codeElement = document.getElementById('code') as HTMLTextAreaElement;\nconst viewerElement = document.getElementById('viewer') as HTMLDivElement;\nconst pathsElement = document.getElementById('paths') as HTMLTextAreaElement;\nconst copiedElement = document.getElementById('copied') as HTMLInputElement;\nconst searchElement = document.getElementById('search') as HTMLInputElement;\nconst searchInfoElement = document.getElementById(\n  'searchInfo'\n) as HTMLSpanElement;\nlet viewer = null;\nlet rootNode = document.getElementById('rootNode') as JsonNodeElement;\n\nquerySelectorArray('[data-load]').forEach((link: any) => {\n  const load = link.getAttribute('data-load');\n  if (demoData[load] && !link.loadListener) {\n    link.loadListener = true;\n    link.addEventListener('click', e => {\n      e.preventDefault();\n      loadStructureData(demoData[load], load === 'jsData');\n    });\n  }\n});\n\ncodeElement.addEventListener('input', e => {\n  console.log('show data based on input');\n  showData(codeElement.value);\n});\nsearchElement.addEventListener('input', async e => {\n  if (searchElement.value.length >= 2) {\n    const cursor = await viewer.openBySearch(\n      new RegExp(searchElement.value, 'i')\n    );\n    searchInfoElement.textContent = cursor.matches.length + ' matches';\n\n    searchInfoElement.appendChild(document.createTextNode(' '));\n\n    const prevBtn = searchInfoElement.appendChild(document.createElement('a'));\n    prevBtn.href = 'javascript:';\n    prevBtn.addEventListener('click', e => {\n      e.preventDefault();\n      cursor.previous();\n    });\n    prevBtn.textContent = 'Prev';\n\n    searchInfoElement.appendChild(document.createTextNode(' '));\n\n    const nextBtn = searchInfoElement.appendChild(document.createElement('a'));\n    nextBtn.href = 'javascript:';\n    nextBtn.addEventListener('click', e => {\n      e.preventDefault();\n      cursor.next();\n    });\n    nextBtn.textContent = 'Next';\n  } else {\n    await rootNode.closeNode();\n    viewer.openBySearch(null);\n    searchInfoElement.textContent = '';\n  }\n});\n\nloadStructureData(demoData.simpleData);\n\nasync function loadStructureData(structure, jsData = false) {\n  if (jsData) {\n    codeElement.style.display = 'none';\n    await showData(structure, jsData);\n  } else {\n    const text = JSON.stringify(structure, null, 2);\n    codeElement.style.display = '';\n    codeElement.value = text;\n    await showData(text, jsData);\n  }\n\n  showPaths();\n}\n\nasync function showData(data: any, jsData = false) {\n  const index =\n    'showDataIndex' in viewerElement\n      ? ++(viewerElement['showDataIndex'] as number)\n      : (viewerElement['showDataIndex'] = 0);\n  if (viewerElement.children.length) {\n    viewerElement.removeChild(viewerElement.children[0]);\n  }\n  if (viewer) {\n    viewer.destroy();\n  }\n  try {\n    let _viewer;\n    if (jsData) {\n      _viewer = await BigJsonViewerDom.fromObject(data);\n    } else {\n      _viewer = await BigJsonViewerDom.fromData(data);\n    }\n    if (viewerElement['showDataIndex'] !== index) {\n      _viewer.destroy();\n      return;\n    }\n    viewer = _viewer;\n    rootNode = viewer.getRootElement();\n    rootNode.id = 'rootNode';\n    viewerElement.appendChild(rootNode);\n    await rootNode.openAll(1);\n    setupRootNode();\n  } catch (e) {\n    console.error('BigJsonViewer error', e);\n    const errEl = document.createElement('div');\n    errEl.classList.add('alert', 'alert-danger');\n    errEl.appendChild(document.createTextNode(e.toString()));\n    viewerElement.appendChild(errEl);\n  }\n}\n\nfunction setupRootNode() {\n  const listener = e => {\n    console.log('event', e.type);\n    showPaths();\n  };\n  rootNode.addEventListener('openNode', listener);\n  rootNode.addEventListener('closeNode', listener);\n  rootNode.addEventListener('openedNodes', listener);\n  rootNode.addEventListener('openStub', listener);\n  rootNode.addEventListener('closeStub', listener);\n  rootNode.addEventListener('copyPath', e => {\n    const node = e.target as JsonNodeElement;\n    copiedElement.value = node.jsonNode.path.join('.');\n  });\n}\n\nfunction showPaths() {\n  if (!rootNode || !rootNode.getOpenPaths) {\n    return;\n  }\n\n  pathsElement.value = rootNode\n    .getOpenPaths()\n    .map(path => path.join('.'))\n    .join('\\n');\n}\n\nfunction querySelectorArray(selector: string) {\n  const list = document.querySelectorAll(selector);\n  const result = [];\n  for (let i = 0; i < list.length; i++) {\n    result.push(list[i]);\n  }\n  return result;\n}\n","export * from './big-json-viewer-dom';\nexport * from './model/big-json-viewer.model';\n","import {\n  BigJsonViewerEvent,\n  BigJsonViewerNode,\n  BigJsonViewerOptions,\n  JsonNodesStubElement,\n  PaginatedOption,\n  TreeSearchAreaOption,\n  TreeSearchCursor,\n  TreeSearchMatch\n} from './model/big-json-viewer.model';\nimport {\n  WorkerClient,\n  WorkerClientApi,\n  WorkerClientMock\n} from './helpers/worker-client';\nimport { forEachMatchFromString } from './parser/json-node-search';\nimport { initWorker } from './worker/big-json-viewer.worker.inline';\n\ndeclare var require: any;\n\nexport interface JsonNodeElement extends JsonNodesStubElement {\n  jsonNode: BigJsonViewerNode;\n\n  /**\n   * Opens the given path and returns the JsonNodeElement if the path was found.\n   */\n  openPath(path: string[]): Promise<JsonNodeElement>;\n\n  /**\n   * Opens all nodes with limits.\n   * maxDepth is Infinity by default.\n   * paginated is first by default. This opens only the first page.\n   * all, would open all pages.\n   * none would open no pages and just show the stubs.\n   * Returns the number of opened nodes.\n   */\n  openAll(maxDepth?: number, paginated?: PaginatedOption): Promise<number>;\n\n  /**\n   * Get a list of all opened paths\n   * withsStubs is true by default, it makes sure, that opened stubs are represented\n   */\n  getOpenPaths(withStubs?: boolean): string[][];\n\n  openNode(dispatchEvent?: boolean): Promise<boolean>;\n\n  closeNode(dispatchEvent?: boolean): Promise<boolean>;\n\n  toggleNode(dispatchEvent?: boolean): Promise<boolean>;\n}\n\nexport class BigJsonViewerDom {\n  private workerClient: WorkerClientApi;\n\n  private options: BigJsonViewerOptions = {\n    objectNodesLimit: 50,\n    arrayNodesLimit: 50,\n    labelAsPath: false,\n    linkLabelCopyPath: 'Copy path',\n    linkLabelExpandAll: 'Expand all',\n    workerPath: null,\n    collapseSameValue: 5\n  };\n\n  private currentPattern: RegExp;\n  private currentArea: TreeSearchAreaOption = 'all';\n  private currentMark = null;\n\n  private rootElement: JsonNodeElement;\n\n  private rootNode: BigJsonViewerNode;\n\n  /**\n   * Initialized the viewer with JSON encoded data\n   */\n  public static async fromData(\n    data: ArrayBuffer | string,\n    options?: BigJsonViewerOptions\n  ): Promise<BigJsonViewerDom> {\n    const viewer = new BigJsonViewerDom(options);\n    await viewer.setData(data);\n    return viewer;\n  }\n\n  /**\n   * Initializes the viewer with a JavaScript object\n   */\n  public static async fromObject(\n    data: string | object | null | number | boolean,\n    options?: BigJsonViewerOptions\n  ): Promise<BigJsonViewerDom> {\n    const viewer = new BigJsonViewerDom(options);\n    await viewer.setObject(data);\n    return viewer;\n  }\n\n  protected constructor(options?: BigJsonViewerOptions) {\n    if (options) {\n      Object.assign(this.options, options);\n    }\n  }\n\n  protected async getWorkerClient() {\n    if (!this.workerClient) {\n      try {\n        const worker = this.options.workerPath\n          ? new Worker(this.options.workerPath)\n          : initWorker();\n        const client = new WorkerClient(worker);\n        await client.initWorker();\n        this.workerClient = client;\n      } catch (e) {\n        console.warn(\n          'Could not instantiate Worker ' +\n            this.options.workerPath +\n            ', using mock',\n          e\n        );\n        const serviceModule = require('./big-json-viewer-service');\n        const service = new serviceModule.BigJsonViewerService();\n        this.workerClient = new WorkerClientMock(service);\n      }\n    }\n    return this.workerClient;\n  }\n\n  protected async setData(\n    data: ArrayBuffer | string\n  ): Promise<BigJsonViewerNode> {\n    const client = await this.getWorkerClient();\n    this.rootNode = await client.call('initWithData', data);\n    return this.rootNode;\n  }\n\n  protected async setObject(data: any): Promise<BigJsonViewerNode> {\n    const client = await this.getWorkerClient();\n    this.rootNode = await client.call('initWithJs', data);\n    return this.rootNode;\n  }\n\n  protected async getChildNodes(\n    path: string[],\n    start: number,\n    limit: number\n  ): Promise<BigJsonViewerNode[]> {\n    const client = await this.getWorkerClient();\n    return client.call('getNodes', path, start, limit);\n  }\n\n  protected async getSearchMatches(\n    pattern: RegExp,\n    searchArea: TreeSearchAreaOption\n  ): Promise<TreeSearchMatch[]> {\n    const client = await this.getWorkerClient();\n    return await client.call('search', pattern, searchArea);\n  }\n\n  protected async getKeyIndex(path: string[], key: string): Promise<number> {\n    const client = await this.getWorkerClient();\n    return await client.call('getKeyIndex', path, key);\n  }\n\n  /**\n   * Destroys the viewer and frees resources like the worker\n   */\n  public destroy() {\n    if (this.workerClient) {\n      this.workerClient.destroy();\n      this.workerClient = null;\n    }\n    this.rootElement = null;\n    this.currentPattern = null;\n  }\n\n  public getRootElement(): JsonNodeElement {\n    if (this.rootElement) {\n      return this.rootElement;\n    }\n    if (this.rootNode) {\n      const nodeElement = this.getNodeElement(this.rootNode);\n      nodeElement.classList.add('json-node-root');\n      this.rootElement = nodeElement;\n      return nodeElement;\n    }\n    return null;\n  }\n\n  protected getNodeElement(node: BigJsonViewerNode): JsonNodeElement {\n    const element = document.createElement('div') as JsonNodeElement;\n    element.classList.add('json-node');\n\n    element.jsonNode = node;\n\n    const header = this.getNodeHeader(node);\n    element.headerElement = element.appendChild(header);\n\n    this.attachInteractivity(element, node);\n\n    return element;\n  }\n\n  protected attachInteractivity(\n    nodeElement: JsonNodeElement,\n    node: BigJsonViewerNode\n  ) {\n    nodeElement.isNodeOpen = (): boolean => {\n      if (this.isOpenableNode(node)) {\n        return nodeElement.headerElement.classList.contains('json-node-open');\n      }\n      return false;\n    };\n    nodeElement.openNode = async (dispatchEvent = false) => {\n      if (this.isOpenableNode(node)) {\n        return await this.openNode(nodeElement, dispatchEvent);\n      }\n      return false;\n    };\n    nodeElement.closeNode = async (dispatchEvent = false) => {\n      if (this.isOpenableNode(node)) {\n        return this.closeNode(nodeElement, dispatchEvent);\n      }\n      return false;\n    };\n    nodeElement.toggleNode = async (dispatchEvent = false) => {\n      if (nodeElement.isNodeOpen()) {\n        return await nodeElement.closeNode(dispatchEvent);\n      } else {\n        return await nodeElement.openNode(dispatchEvent);\n      }\n    };\n\n    nodeElement.openPath = async (path: string[]): Promise<JsonNodeElement> => {\n      if (this.isOpenableNode(node)) {\n        return await this.openPath(nodeElement, path, true);\n      }\n      return null;\n    };\n\n    nodeElement.openAll = async (\n      maxDepth = Infinity,\n      paginated = 'first'\n    ): Promise<number> => {\n      if (this.isOpenableNode(node)) {\n        return await this.openAll(nodeElement, maxDepth, paginated);\n      }\n      return 0;\n    };\n\n    nodeElement.getOpenPaths = (withStubs = true): string[][] => {\n      if (this.isOpenableNode(node)) {\n        return this.getOpenPaths(nodeElement, withStubs);\n      }\n      return [];\n    };\n  }\n\n  protected attachClickToggleListener(anchor: HTMLAnchorElement) {\n    anchor.addEventListener('click', e => {\n      e.preventDefault();\n      const nodeElement = this.findNodeElement(anchor);\n      if (nodeElement) {\n        nodeElement.toggleNode(true);\n      }\n    });\n  }\n\n  protected isOpenableNode(node: BigJsonViewerNode) {\n    return (node.type === 'array' || node.type === 'object') && node.length;\n  }\n\n  protected closeNode(nodeElement: JsonNodeElement, dispatchEvent = false) {\n    if (!nodeElement.isNodeOpen()) {\n      return false;\n    }\n    if (nodeElement.childrenElement) {\n      nodeElement.headerElement.classList.remove('json-node-open');\n      nodeElement.removeChild(nodeElement.childrenElement);\n      nodeElement.childrenElement = null;\n      if (dispatchEvent) {\n        this.dispatchNodeEvent('closeNode', nodeElement);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  protected refreshHeaders(nodeElement: JsonNodeElement) {\n    const header = this.getNodeHeader(nodeElement.jsonNode);\n    if (nodeElement.isNodeOpen()) {\n      header.classList.add('json-node-open');\n    }\n    nodeElement.headerElement.parentElement.replaceChild(\n      header,\n      nodeElement.headerElement\n    );\n    nodeElement.headerElement = header;\n\n    if (nodeElement.childrenElement) {\n      this.getVisibleChildren(nodeElement.childrenElement.children).forEach(\n        element => this.refreshHeaders(element)\n      );\n    }\n  }\n\n  protected getHighlightedText(\n    text: string,\n    pattern: RegExp\n  ): DocumentFragment {\n    const fragment = document.createDocumentFragment();\n    if (!pattern) {\n      fragment.appendChild(document.createTextNode(text));\n      return fragment;\n    }\n    let lastIndex = 0;\n    forEachMatchFromString(pattern, text, (index, length) => {\n      if (lastIndex < index) {\n        fragment.appendChild(\n          document.createTextNode(text.substring(lastIndex, index))\n        );\n      }\n      const mark = document.createElement('mark');\n      mark.appendChild(document.createTextNode(text.substr(index, length)));\n      fragment.appendChild(mark);\n      lastIndex = index + length;\n    });\n    if (lastIndex !== text.length) {\n      fragment.appendChild(\n        document.createTextNode(text.substring(lastIndex, text.length))\n      );\n    }\n    return fragment;\n  }\n\n  /**\n   * Opens the tree nodes based on a pattern\n   * openLimit is 1 by default, you can provide Infinity for all\n   * searchArea is 'all' by default\n   */\n  public async openBySearch(\n    pattern: RegExp,\n    openLimit = 1,\n    searchArea: TreeSearchAreaOption = 'all'\n  ): Promise<TreeSearchCursor> {\n    const nodeElement = this.rootElement;\n    this.currentPattern = pattern;\n    this.currentArea = searchArea;\n    if (!pattern) {\n      this.closeNode(nodeElement, true);\n      return null;\n    }\n\n    this.refreshHeaders(nodeElement);\n\n    const viewer = this;\n    const matches = await this.getSearchMatches(pattern, searchArea);\n    const cursor: TreeSearchCursor = {\n      matches: matches,\n      index: 0,\n      async navigateTo(index: number) {\n        this.index = index;\n        const match = this.matches[index];\n        if (!match) {\n          console.warn(\n            'searchIndex does not exist on ' + this.matches.length,\n            index\n          );\n          return;\n        }\n        const openedElement = await viewer.openSearchMatch(nodeElement, match);\n        if (openedElement) {\n          if (openedElement.scrollIntoView) {\n            openedElement.scrollIntoView({ block: 'center' });\n          }\n          if (viewer.currentMark) {\n            viewer.currentMark.classList.remove('highlight-active');\n          }\n          viewer.currentMark = viewer.findMarkForMatch(openedElement, match);\n          if (viewer.currentMark) {\n            viewer.currentMark.classList.add('highlight-active');\n          }\n          return true;\n        }\n        return false;\n      },\n      next() {\n        return this.navigateTo(\n          this.index + 1 >= this.matches.length ? 0 : this.index + 1\n        );\n      },\n      previous() {\n        return this.navigateTo(\n          this.index - 1 < 0 ? this.matches.length : this.index - 1\n        );\n      }\n    };\n\n    const length = Math.min(matches.length, openLimit);\n    for (let i = 0; i < length && i < openLimit; i++) {\n      await this.openSearchMatch(nodeElement, matches[i]);\n    }\n\n    this.dispatchNodeEvent('openedNodes', nodeElement);\n\n    if (matches.length) {\n      await cursor.navigateTo(0);\n    }\n\n    return cursor;\n  }\n\n  protected findMarkForMatch(\n    nodeElement: JsonNodeElement,\n    match: TreeSearchMatch\n  ): HTMLElement {\n    let children = null,\n      expectIndex = 0;\n    if (match.key !== undefined) {\n      const label = nodeElement.headerElement.querySelector('.json-node-label');\n      if (label) {\n        children = label.childNodes;\n        expectIndex = match.key;\n      }\n    }\n\n    if (match.value !== undefined) {\n      const value = nodeElement.headerElement.querySelector('.json-node-value');\n      if (value) {\n        children = value.childNodes;\n        expectIndex = match.value;\n      }\n    }\n\n    if (children) {\n      let index = nodeElement.jsonNode.type === 'string' ? -1 : 0;\n      for (let i = 0; i < children.length; i++) {\n        const cn = children[i];\n        if (cn.nodeType === Node.TEXT_NODE) {\n          index += cn.textContent.length;\n        }\n        if (\n          cn.nodeType === Node.ELEMENT_NODE &&\n          (cn as HTMLElement).tagName === 'MARK' &&\n          expectIndex === index\n        ) {\n          return cn as HTMLElement;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  protected async openSearchMatch(\n    nodeElement: JsonNodeElement,\n    match: TreeSearchMatch\n  ): Promise<JsonNodeElement> {\n    if (match.key !== undefined && match.path.length) {\n      if (match.path.length) {\n        const matchNodeElementParent = await this.openPath(\n          nodeElement,\n          match.path.slice(0, -1)\n        ); // open the parent\n        if (matchNodeElementParent) {\n          return await this.openKey(\n            matchNodeElementParent,\n            match.path[match.path.length - 1]\n          ); // ensure the key is visible\n        }\n      }\n    } else if (match.value !== undefined) {\n      return await this.openPath(nodeElement, match.path);\n    }\n    return null;\n  }\n\n  protected getOpenPaths(nodeElement: JsonNodeElement, withSubs): string[][] {\n    const result: string[][] = [];\n    if (!nodeElement.isNodeOpen()) {\n      return result;\n    }\n\n    const children = nodeElement.childrenElement.children;\n    const nodeElements = this.getVisibleChildren(children);\n    for (let i = 0; i < nodeElements.length; i++) {\n      const element = nodeElements[i];\n      if (element.isNodeOpen()) {\n        result.push(...this.getOpenPaths(element, withSubs));\n      }\n    }\n\n    const limit = this.getPaginationLimit(nodeElement.jsonNode);\n    // find open stubs\n    if (!result.length && limit) {\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i] as JsonNodesStubElement;\n        if (\n          child.isNodeOpen() &&\n          child.childrenElement &&\n          child.childrenElement.children.length\n        ) {\n          const first = child.childrenElement.children[0] as JsonNodeElement;\n          if (first.jsonNode) {\n            result.push(first.jsonNode.path);\n          }\n        }\n      }\n    }\n    if (!result.length) {\n      result.push(nodeElement.jsonNode.path);\n    }\n    return result;\n  }\n\n  protected async openNode(\n    nodeElement: JsonNodeElement,\n    dispatchEvent = false\n  ): Promise<boolean> {\n    if (nodeElement.isNodeOpen()) {\n      return false;\n    }\n    nodeElement.headerElement.classList.add('json-node-open');\n\n    const children = await this.getPaginatedNodeChildren(nodeElement);\n\n    nodeElement.childrenElement = nodeElement.appendChild(children);\n\n    if (dispatchEvent) {\n      this.dispatchNodeEvent('openNode', nodeElement);\n    }\n    return true;\n  }\n\n  protected dispatchNodeEvent(\n    type: BigJsonViewerEvent,\n    nodeElement: JsonNodesStubElement\n  ) {\n    let event: Event;\n    if (document.createEvent) {\n      event = document.createEvent('Event');\n      event.initEvent(type, true, false);\n    } else {\n      event = new Event(type, {\n        bubbles: true,\n        cancelable: false\n      });\n    }\n    nodeElement.dispatchEvent(event);\n  }\n\n  protected async openKey(\n    nodeElement: JsonNodeElement,\n    key: string\n  ): Promise<JsonNodeElement> {\n    const node = nodeElement.jsonNode;\n    let children: HTMLCollection = null;\n    let index = -1;\n    if (node.type === 'object') {\n      index = await this.getKeyIndex(node.path, key);\n      if (index === -1) {\n        return null;\n      }\n\n      await nodeElement.openNode();\n\n      // find correct stub in pagination\n      if (node.length > this.options.objectNodesLimit) {\n        const stubIndex = Math.floor(index / this.options.objectNodesLimit);\n        const stub = nodeElement.childrenElement.children[\n          stubIndex\n        ] as JsonNodesStubElement;\n        if (stub) {\n          await stub.openNode();\n          index -= stubIndex * this.options.objectNodesLimit;\n          children = stub.childrenElement.children;\n        }\n      } else {\n        children = nodeElement.childrenElement.children;\n      }\n    }\n    if (node.type === 'array') {\n      index = parseInt(key);\n      if (isNaN(index) || index >= node.length || index < 0) {\n        return null;\n      }\n\n      await nodeElement.openNode();\n      // find correct stub in pagination\n      if (node.length > this.options.arrayNodesLimit) {\n        const stubIndex = Math.floor(index / this.options.arrayNodesLimit);\n        const stub = nodeElement.childrenElement.children[\n          stubIndex\n        ] as JsonNodesStubElement;\n        if (stub) {\n          await stub.openNode();\n          index -= stubIndex * this.options.arrayNodesLimit;\n          children = stub.childrenElement.children;\n        }\n      } else {\n        children = nodeElement.childrenElement.children;\n      }\n    }\n    if (children && index >= 0 && index < children.length) {\n      const childNodeElement = children[index] as JsonNodeElement;\n      if (!childNodeElement.jsonNode) {\n        return null;\n      }\n      return childNodeElement;\n    }\n    return null;\n  }\n\n  protected async openPath(\n    nodeElement: JsonNodeElement,\n    path: string[],\n    dispatchEvent = false\n  ): Promise<JsonNodeElement> {\n    if (!path.length) {\n      await this.openNode(nodeElement, dispatchEvent);\n      return nodeElement;\n    }\n\n    let element = nodeElement;\n    for (let i = 0; i < path.length; i++) {\n      if (!element) {\n        return null;\n      }\n      element = await this.openKey(element, path[i]);\n      if (element) {\n        await element.openNode();\n      }\n    }\n    if (dispatchEvent) {\n      this.dispatchNodeEvent('openedNodes', nodeElement);\n    }\n    return element;\n  }\n\n  protected async openAll(\n    nodeElement: JsonNodeElement,\n    maxDepth: number,\n    paginated: PaginatedOption,\n    dispatchEvent = false\n  ): Promise<number> {\n    await nodeElement.openNode();\n    let opened = 1;\n    if (maxDepth <= 1 || !nodeElement.childrenElement) {\n      return opened;\n    }\n    const newMaxDepth = maxDepth === Infinity ? Infinity : maxDepth - 1;\n\n    opened += await this.openAllChildren(\n      nodeElement.childrenElement.children,\n      newMaxDepth,\n      paginated\n    );\n\n    if (dispatchEvent) {\n      this.dispatchNodeEvent('openedNodes', nodeElement);\n    }\n\n    return opened;\n  }\n\n  protected async openAllChildren(\n    children: HTMLCollection,\n    maxDepth: number,\n    paginated: PaginatedOption\n  ): Promise<number> {\n    let opened = 0;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i] as JsonNodeElement;\n      if (child.jsonNode) {\n        // is a node\n        opened += await child.openAll(maxDepth, paginated);\n      } else if (child.openNode) {\n        // is a stub\n        if (paginated === 'none') {\n          return opened;\n        }\n        await child.openNode();\n        if (child.childrenElement) {\n          opened += await this.openAllChildren(\n            child.childrenElement.children,\n            maxDepth,\n            paginated\n          );\n        }\n        if (paginated === 'first') {\n          return opened;\n        }\n      }\n    }\n    return opened;\n  }\n\n  /**\n   * Returns the pagination limit, if the node should have\n   */\n  protected getPaginationLimit(node: BigJsonViewerNode): number {\n    if (node.type === 'array' && node.length > this.options.arrayNodesLimit) {\n      return this.options.arrayNodesLimit;\n    }\n    if (node.type === 'object' && node.length > this.options.objectNodesLimit) {\n      return this.options.objectNodesLimit;\n    }\n    return 0;\n  }\n\n  protected getVisibleChildren(children: HTMLCollection): JsonNodeElement[] {\n    const result: JsonNodeElement[] = [];\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i] as JsonNodeElement;\n      if (child.jsonNode) {\n        // is a node\n        result.push(child);\n      } else if (\n        child.openNode &&\n        child.isNodeOpen() &&\n        child.childrenElement\n      ) {\n        // is a stub\n        result.push(...this.getVisibleChildren(child.childrenElement.children));\n      }\n    }\n    return result;\n  }\n\n  protected async getPaginatedNodeChildren(\n    nodeElement: JsonNodeElement\n  ): Promise<HTMLDivElement> {\n    const node = nodeElement.jsonNode;\n    const element = document.createElement('div');\n    element.classList.add('json-node-children');\n\n    const limit = this.getPaginationLimit(node);\n    if (limit) {\n      for (let start = 0; start < node.length; start += limit) {\n        element.appendChild(this.getPaginationStub(node, start, limit));\n      }\n    } else {\n      const nodes = await this.getChildNodes(node.path, 0, limit);\n      this.addChildNodes(\n        nodes,\n        element,\n        node.type === 'array' ? this.options.collapseSameValue : Infinity\n      );\n    }\n    return element;\n  }\n\n  protected getPaginationStub(\n    node: BigJsonViewerNode,\n    start: number,\n    limit: number\n  ): JsonNodesStubElement {\n    const stubElement = document.createElement('div') as JsonNodesStubElement;\n    stubElement.classList.add('json-node-stub');\n\n    const anchor = document.createElement('a');\n    anchor.href = 'javascript:';\n    anchor.classList.add('json-node-stub-toggler');\n\n    stubElement.headerElement = anchor;\n\n    this.generateAccessor(anchor);\n\n    const end = Math.min(node.length, start + limit) - 1;\n    const label = document.createElement('span');\n    label.classList.add('json-node-label');\n    label.appendChild(\n      document.createTextNode('[' + start + ' ... ' + end + ']')\n    );\n    anchor.appendChild(label);\n\n    stubElement.appendChild(anchor);\n\n    anchor.addEventListener('click', async e => {\n      e.preventDefault();\n      if (stubElement.isNodeOpen()) {\n        this.closePaginationStub(stubElement, true);\n      } else {\n        this.openPaginationStub(\n          stubElement,\n          node,\n          await this.getChildNodes(node.path, start, limit),\n          true\n        );\n      }\n    });\n\n    stubElement.isNodeOpen = () => {\n      return anchor.classList.contains('json-node-open');\n    };\n\n    stubElement.openNode = async () => {\n      if (!stubElement.isNodeOpen()) {\n        await this.openPaginationStub(\n          stubElement,\n          node,\n          await this.getChildNodes(node.path, start, limit)\n        );\n        return true;\n      }\n      return false;\n    };\n\n    stubElement.closeNode = async () => {\n      if (stubElement.isNodeOpen()) {\n        this.closePaginationStub(stubElement);\n        return true;\n      }\n      return false;\n    };\n\n    stubElement.toggleNode = () => {\n      if (stubElement.isNodeOpen()) {\n        return stubElement.closeNode();\n      } else {\n        return stubElement.openNode();\n      }\n    };\n\n    return stubElement;\n  }\n\n  protected closePaginationStub(\n    stubElement: JsonNodesStubElement,\n    dispatchEvent = false\n  ) {\n    if (stubElement.childrenElement) {\n      stubElement.headerElement.classList.remove('json-node-open');\n      stubElement.removeChild(stubElement.childrenElement);\n      stubElement.childrenElement = null;\n      if (dispatchEvent) {\n        this.dispatchNodeEvent('closeStub', stubElement);\n      }\n    }\n  }\n\n  protected openPaginationStub(\n    stubElement: JsonNodesStubElement,\n    node: BigJsonViewerNode,\n    nodes: BigJsonViewerNode[],\n    dispatchEvent = false\n  ) {\n    stubElement.headerElement.classList.add('json-node-open');\n    const children = document.createElement('div');\n    children.classList.add('json-node-children');\n    stubElement.childrenElement = children;\n    this.addChildNodes(\n      nodes,\n      children,\n      node.type === 'array' ? this.options.collapseSameValue : Infinity\n    );\n    stubElement.appendChild(children);\n    if (dispatchEvent) {\n      this.dispatchNodeEvent('openStub', stubElement);\n    }\n  }\n\n  protected addChildNodes(\n    nodes: BigJsonViewerNode[],\n    parent: HTMLElement,\n    collapseSameValue: number\n  ) {\n    let lastValue: any;\n    let sameValueCount = 0;\n\n    nodes.forEach((node, i) => {\n      if (\n        node.type !== 'object' &&\n        node.type !== 'array' &&\n        lastValue === node.value\n      ) {\n        sameValueCount++;\n        if (sameValueCount >= collapseSameValue) {\n          return;\n        }\n      } else if (sameValueCount >= collapseSameValue) {\n        parent.appendChild(this.getCollapseIndicator(sameValueCount));\n        parent.appendChild(this.getNodeElement(nodes[i - 1]));\n        sameValueCount = 0;\n      } else {\n        sameValueCount = 0;\n      }\n      parent.appendChild(this.getNodeElement(node));\n      lastValue = node.value;\n    });\n    if (sameValueCount >= collapseSameValue) {\n      parent.appendChild(\n        this.getCollapseIndicator(sameValueCount - collapseSameValue)\n      );\n      parent.appendChild(this.getNodeElement(nodes[nodes.length - 1]));\n    }\n  }\n\n  protected getCollapseIndicator(count): HTMLDivElement {\n    const element = document.createElement('div');\n    element.classList.add('json-node-collapse');\n    element.appendChild(document.createTextNode('... [' + count + '] ...'));\n    return element;\n  }\n\n  protected getNodeHeader(node: BigJsonViewerNode) {\n    const element = document.createElement('div');\n    element.classList.add('json-node-header');\n    element.classList.add('json-node-' + node.type);\n\n    const keyHighlightPattern =\n      this.currentArea === 'all' || this.currentArea === 'keys'\n        ? this.currentPattern\n        : null;\n    const valueHighlightPattern =\n      this.currentArea === 'all' || this.currentArea === 'values'\n        ? this.currentPattern\n        : null;\n\n    if (node.type === 'object' || node.type === 'array') {\n      const anchor = document.createElement('a');\n      anchor.classList.add('json-node-toggler');\n      anchor.href = 'javascript:';\n      if (node.length) {\n        this.attachClickToggleListener(anchor);\n        this.generateAccessor(anchor);\n      }\n      this.generateLabel(anchor, node, keyHighlightPattern);\n      this.generateTypeInfo(anchor, node);\n      element.appendChild(anchor);\n    } else {\n      this.generateLabel(element, node, keyHighlightPattern);\n      this.generateValue(element, node, valueHighlightPattern);\n      this.generateTypeInfo(element, node);\n    }\n\n    this.generateLinks(element, node);\n\n    return element;\n  }\n\n  protected generateAccessor(parent: HTMLElement) {\n    const span = document.createElement('span');\n    span.classList.add('json-node-accessor');\n    parent.appendChild(span);\n  }\n\n  protected generateTypeInfo(parent: HTMLElement, node: BigJsonViewerNode) {\n    const typeInfo = document.createElement('span');\n    typeInfo.classList.add('json-node-type');\n    if (node.type === 'object') {\n      typeInfo.appendChild(\n        document.createTextNode('Object(' + node.length + ')')\n      );\n    } else if (node.type === 'array') {\n      typeInfo.appendChild(\n        document.createTextNode('Array[' + node.length + ']')\n      );\n    } else {\n      typeInfo.appendChild(document.createTextNode(node.type));\n    }\n    parent.appendChild(typeInfo);\n  }\n\n  protected generateLabel(\n    parent: HTMLElement,\n    node: BigJsonViewerNode,\n    highlightPattern: RegExp\n  ) {\n    if (!node.path.length) {\n      return;\n    }\n    const label = document.createElement('span');\n    label.classList.add('json-node-label');\n    if (this.options.labelAsPath && node.path.length > 1) {\n      const prefix = document.createElement('span');\n      prefix.classList.add('json-node-label-prefix');\n      prefix.appendChild(\n        document.createTextNode(\n          node.path.slice(0, node.path.length - 1).join('.') + '.'\n        )\n      );\n      label.appendChild(prefix);\n    }\n\n    label.appendChild(\n      this.getHighlightedText(node.path[node.path.length - 1], highlightPattern)\n    );\n\n    parent.appendChild(label);\n    parent.appendChild(document.createTextNode(': '));\n  }\n\n  protected generateValue(\n    parent: HTMLElement,\n    node: BigJsonViewerNode,\n    highlightPattern: RegExp\n  ) {\n    const valueElement = document.createElement('span');\n    valueElement.classList.add('json-node-value');\n    valueElement.appendChild(\n      this.getHighlightedText(JSON.stringify(node.value), highlightPattern)\n    );\n    parent.appendChild(valueElement);\n  }\n\n  protected getLabelNode(label: string | HTMLElement): Node {\n    if (label instanceof Node) {\n      return label;\n    }\n    return document.createTextNode(label);\n  }\n\n  protected generateLinks(parent: HTMLElement, node: BigJsonViewerNode) {\n    if (this.isOpenableNode(node) && this.options.linkLabelExpandAll) {\n      const link = parent.appendChild(document.createElement('a'));\n      link.classList.add('json-node-link');\n      link.href = 'javascript:';\n      link.appendChild(this.getLabelNode(this.options.linkLabelExpandAll));\n      link.addEventListener('click', e => {\n        e.preventDefault();\n        const nodeElement = this.findNodeElement(parent);\n        if (nodeElement && this.isOpenableNode(nodeElement.jsonNode)) {\n          this.openAll(nodeElement, Infinity, 'first', true);\n        }\n      });\n    }\n\n    if (node.path.length && this.options.linkLabelCopyPath) {\n      const link = parent.appendChild(document.createElement('a'));\n      link.classList.add('json-node-link');\n      link.href = 'javascript:';\n      link.appendChild(this.getLabelNode(this.options.linkLabelCopyPath));\n      link.addEventListener('click', e => {\n        e.preventDefault();\n        const input = document.createElement('input');\n        input.type = 'text';\n        input.value = node.path.join('.');\n        const nodeElement = this.findNodeElement(parent);\n        this.dispatchNodeEvent('copyPath', nodeElement);\n        parent.appendChild(input);\n        input.select();\n        try {\n          if (!document.execCommand('copy')) {\n            console.warn('Unable to copy path to clipboard');\n          }\n        } catch (e) {\n          console.error('Unable to copy path to clipboard', e);\n        }\n        parent.removeChild(input);\n      });\n    }\n\n    if (typeof this.options.addLinksHook === 'function') {\n      for (const element of this.options.addLinksHook(node)) {\n        parent.appendChild(element);\n      }\n    }\n  }\n\n  protected findNodeElement(el: HTMLElement): JsonNodeElement {\n    while (el && !el['jsonNode']) {\n      el = el.parentElement;\n    }\n    return el as JsonNodeElement;\n  }\n}\n","export interface WorkerClientApi {\n  call(handler: string, ...args): Promise<any>;\n\n  callWorker(handler: string, transfers: any[], ...args): Promise<any>;\n\n  destroy();\n}\n\nexport class WorkerClient implements WorkerClientApi {\n  private requestIndex = 0;\n  private requestCallbacks = {};\n  private initialized;\n\n  constructor(private worker: Worker) {}\n\n  public initWorker(): Promise<boolean> {\n    return new Promise((resolve, reject) => {\n      this.worker.onmessage = msg => {\n        const data = msg.data;\n        if (data._init === true) {\n          this.initialized = true;\n          resolve(true);\n          return;\n        }\n        if (data.resultId && this.requestCallbacks[data.resultId]) {\n          const callb = this.requestCallbacks[data.resultId];\n          delete this.requestCallbacks[data.resultId];\n          callb(data);\n        }\n      };\n      this.worker.onerror = e => {\n        if (!this.initialized) {\n          reject(e);\n        } else {\n          console.error('Worker error', e);\n        }\n      };\n      this.worker.postMessage({ _init: true });\n    });\n  }\n\n  public call(handler, ...args): Promise<any> {\n    return this.callWorker(handler, undefined, ...args);\n  }\n\n  public callWorker(handler, transfers = undefined, ...args): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const resultId = ++this.requestIndex;\n      this.requestCallbacks[resultId] = data => {\n        if (data.error !== undefined) {\n          reject(data.error);\n          return;\n        }\n        resolve(data.result);\n      };\n      this.worker.postMessage(\n        {\n          handler: handler,\n          args: args,\n          resultId: resultId\n        },\n        transfers\n      );\n    });\n  }\n\n  public destroy() {\n    this.worker.terminate();\n    this.worker = null;\n    this.requestCallbacks = null;\n  }\n}\n\nexport class WorkerClientMock implements WorkerClientApi {\n  constructor(private provider) {}\n\n  public call(handler, ...args): Promise<any> {\n    return this.callWorker(handler, undefined, ...args);\n  }\n\n  public callWorker(handler, transfers = undefined, ...args): Promise<any> {\n    return new Promise(resolve => {\n      resolve(this.provider[handler].apply(this.provider, args));\n    });\n  }\n  public destroy() {\n    this.provider = null;\n  }\n}\n","/* tslint:disable */\nexport function initWorker() {\n  const blob = new Blob([\"!function(e,t,r,s,o,n,a,i){var h=\\\"undefined\\\"!=typeof globalThis?globalThis:\\\"undefined\\\"!=typeof self?self:\\\"undefined\\\"!=typeof window?window:\\\"undefined\\\"!=typeof global?global:{},l=\\\"function\\\"==typeof h[s]&&h[s],d=l.i||{},p=l.cache||{},u=\\\"undefined\\\"!=typeof module&&\\\"function\\\"==typeof module.require&&module.require.bind(module);function f(t,r){if(!p[t]){if(!e[t]){if(o[t])return o[t];var n=\\\"function\\\"==typeof h[s]&&h[s];if(!r&&n)return n(t,!0);if(l)return l(t,!0);if(u&&\\\"string\\\"==typeof t)return u(t);var a=Error(\\\"Cannot find module '\\\"+t+\\\"'\\\");throw a.code=\\\"MODULE_NOT_FOUND\\\",a}d.resolve=function(r){var s=e[t][1][r];return null!=s?s:r},d.cache={};var i=p[t]=new f.Module(t);e[t][0].call(i.exports,d,i,i.exports,h)}return p[t].exports;function d(e){var t=d.resolve(e);if(!1===t)return{};if(Array.isArray(t)){var r={__esModule:!0};return t.forEach(function(e){var t=e[0],s=e[1],o=e[2]||e[0],n=f(s);\\\"*\\\"===t?Object.keys(n).forEach(function(e){\\\"default\\\"===e||\\\"__esModule\\\"===e||Object.prototype.hasOwnProperty.call(r,e)||Object.defineProperty(r,e,{enumerable:!0,get:function(){return n[e]}})}):\\\"*\\\"===o?Object.defineProperty(r,t,{enumerable:!0,value:n}):Object.defineProperty(r,t,{enumerable:!0,get:function(){return\\\"default\\\"===o?n.__esModule?n.default:n:n[o]}})}),r}return f(t)}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.require=u,this.exports={}},f.modules=e,f.cache=p,f.parent=l,f.distDir=void 0,f.publicUrl=void 0,f.devServer=void 0,f.i=d,f.register=function(t,r){e[t]=[function(e,t){t.exports=r},{}]},Object.defineProperty(f,\\\"root\\\",{get:function(){return h[s]}}),h[s]=f;for(var c=0;c<t.length;c++)f(t[c]);if(r){var y=f(r);\\\"object\\\"==typeof exports&&\\\"undefined\\\"!=typeof module?module.exports=y:\\\"function\\\"==typeof define&&define.amd&&define(function(){return y})}}({kGz5N:[function(e,t,r,s){var o=e(\\\"../helpers/worker-provider\\\"),n=e(\\\"../big-json-viewer-service\\\");(0,o.initProvider)(new(0,n.BigJsonViewerService))},{\\\"../helpers/worker-provider\\\":\\\"vpIKR\\\",\\\"../big-json-viewer-service\\\":\\\"lsYGb\\\"}],vpIKR:[function(e,t,r,s){var o=e(\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\");function n(e,t=self){t.onmessage=function(r){let s=r.data;if(s._init)return void t.postMessage({_init:!0});if(s.handler&&e[s.handler])try{let r=e[s.handler].apply(e,s.args);s.resultId&&t.postMessage({resultId:s.resultId,result:r})}catch(e){s.resultId&&t.postMessage({resultId:s.resultId,error:e.toString()})}}}o.defineInteropFlag(r),o.export(r,\\\"initProvider\\\",()=>n)},{\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\":\\\"kdXvs\\\"}],kdXvs:[function(e,t,r,s){r.interopDefault=function(e){return e&&e.__esModule?e:{default:e}},r.defineInteropFlag=function(e){Object.defineProperty(e,\\\"__esModule\\\",{value:!0})},r.exportAll=function(e,t){return Object.keys(e).forEach(function(r){\\\"default\\\"===r||\\\"__esModule\\\"===r||Object.prototype.hasOwnProperty.call(t,r)||Object.defineProperty(t,r,{enumerable:!0,get:function(){return e[r]}})}),t},r.export=function(e,t,r){Object.defineProperty(e,t,{enumerable:!0,get:r})}},{}],lsYGb:[function(e,t,r,s){var o=e(\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\");o.defineInteropFlag(r),o.export(r,\\\"BigJsonViewerService\\\",()=>h);var n=e(\\\"./parser/json-node-search\\\"),a=e(\\\"./parser/buffer-json-parser\\\"),i=e(\\\"./parser/js-parser\\\");class h{initWithData(e){return this.rootNode=new(0,a.BufferJsonParser)(e).getRootNodeInfo(),this.getRenderInfo(this.rootNode)}initWithJs(e){return this.rootNode=new(0,i.JsParser)(e).getRootNodeInfo(),this.getRenderInfo(this.rootNode)}getNodes(e,t,r){let s=this.rootNode.getByPath(e);return s&&\\\"object\\\"===s.type?s.getObjectNodes(t,r).map(e=>this.getRenderInfo(e)):s&&\\\"array\\\"===s.type?s.getArrayNodes(t,r).map(e=>this.getRenderInfo(e)):null}getKeyIndex(e,t){let r=this.rootNode.getByPath(e);return r?r.getObjectKeys().indexOf(t):-1}search(e,t){return(0,n.searchJsonNodes)(this.rootNode,e,t)}getRenderInfo(e){let t={type:e.type,length:e.length,path:e.path,openable:this.isOpenableNode(e)};return t.openable||(t.value=e.getValue()),t}isOpenableNode(e){return(\\\"array\\\"===e.type||\\\"object\\\"===e.type)&&!!e.length}}},{\\\"./parser/json-node-search\\\":\\\"bjnFk\\\",\\\"./parser/buffer-json-parser\\\":\\\"aPMcZ\\\",\\\"./parser/js-parser\\\":\\\"6NMJx\\\",\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\":\\\"kdXvs\\\"}],bjnFk:[function(e,t,r,s){var o=e(\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\");function n(e,t,r){(e=a(e)).lastIndex=0;let s=null;for(;null!==(s=e.exec(t));)r(s.index,s[0].length);e.lastIndex=0}function a(e){if(!e.global){let t=\\\"g\\\"+(e.ignoreCase?\\\"i\\\":\\\"\\\")+(e.multiline?\\\"m\\\":\\\"\\\");return new RegExp(e.source,t)}return e}o.defineInteropFlag(r),o.export(r,\\\"searchJsonNodes\\\",()=>function e(t,r,s=\\\"all\\\"){r=a(r);let o=[];return t.path.length&&(\\\"all\\\"===s||\\\"keys\\\"===s)&&n(r,t.path[t.path.length-1],(e,r)=>{o.push({path:t.path,key:e,length:r})}),\\\"object\\\"===t.type?t.getObjectNodes().forEach(t=>{o.push(...e(t,r,s))}):\\\"array\\\"===t.type?t.getArrayNodes().forEach(t=>{o.push(...e(t,r,s))}):(\\\"all\\\"===s||\\\"values\\\"===s)&&n(r,String(t.getValue()),(e,r)=>{o.push({path:t.path,value:e,length:r})}),o}),o.export(r,\\\"forEachMatchFromString\\\",()=>n)},{\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\":\\\"kdXvs\\\"}],aPMcZ:[function(e,t,r,s){var o=e(\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\");o.defineInteropFlag(r),o.export(r,\\\"BufferJsonNodeInfo\\\",()=>d),o.export(r,\\\"BufferJsonParser\\\",()=>p);var n=e(\\\"../helpers/utils\\\");let a=[32,9,10,13],i=\\\"null\\\".split(\\\"\\\").map(e=>e.charCodeAt(0)),h=\\\"true\\\".split(\\\"\\\").map(e=>e.charCodeAt(0)),l=\\\"false\\\".split(\\\"\\\").map(e=>e.charCodeAt(0));class d{constructor(e,t,r){this.path=[],this.parser=e,this.index=t,this.path=r}getObjectKeys(e=0,t){if(\\\"object\\\"!==this.type)throw Error(`Unsupported method on non-object ${this.type}`);(0,n.assertStartLimit)(e,t);let r={path:this.path,objectKeys:[],start:e,limit:t};return this.parser.parseObject(this.index,r),r.objectKeys}getByIndex(e){if(\\\"object\\\"===this.type){let t=this.getObjectNodes(e,1);if(t.length)return t[0]}if(\\\"array\\\"===this.type){let t=this.getArrayNodes(e,1);if(t.length)return t[0]}}getByKey(e){if(\\\"object\\\"===this.type){let t={path:this.path,objectKey:e};return this.parser.parseObject(this.index,t),t.objectNodes?t.objectNodes[0]:void 0}if(\\\"array\\\"===this.type)return this.getByIndex(parseInt(e))}getByPath(e){let t;if(!e)return;if(!e.length)return this;let r=e.slice(),s=this;for(;void 0!==(t=r.shift())&&s;)s=s.getByKey(t);return s}getObjectNodes(e=0,t){if(\\\"object\\\"!==this.type)throw Error(`Unsupported method on non-object ${this.type}`);(0,n.assertStartLimit)(e,t);let r={path:this.path,objectNodes:[],start:e,limit:t};return this.parser.parseObject(this.index,r),r.objectNodes}getArrayNodes(e=0,t){if(\\\"array\\\"!==this.type)throw Error(`Unsupported method on non-array ${this.type}`);(0,n.assertStartLimit)(e,t);let r={path:this.path,arrayNodes:[],start:e,limit:t};return this.parser.parseArray(this.index,r),r.arrayNodes}getValue(){return this.parser.parseNative(this.index,this.index+this.chars)}}class p{constructor(e){if(e instanceof ArrayBuffer)this.data=new Uint16Array(e);else if(\\\"string\\\"==typeof e&&\\\"undefined\\\"!=typeof TextEncoder)this.data=new TextEncoder().encode(e);else if(\\\"string\\\"==typeof e){this.data=new Uint16Array(new ArrayBuffer(2*e.length));for(let t=0;t<e.length;t++)this.data[t]=e.charCodeAt(t)}}getRootNodeInfo(){let e=this.skipIgnored(0),t={path:[],nodeInfo:new d(this,e,[])},r=this.parseValue(e,t,!1);return e===r?null:t.nodeInfo}parseValue(e,t,r=!0){var s,o;let n=this.data[e];if(34===(s=n)||39===s)return this.parseString(e,t);if(45===(o=n)||o>=48&&o<=57)return this.parseNumber(e,t);if(123===n)return this.parseObject(e,t);if(91===n)return this.parseArray(e,t);if(n===h[0])return this.parseToken(e,h,t);if(n===l[0])return this.parseToken(e,l,t);if(n===i[0])return this.parseToken(e,i,t);if(r)throw Error(`parse value unknown token ${u(n)} at ${e}`)}parseObject(e,t){let r=e+1,s=0,o=[],n=[];for(;r<=this.data.length;){var a;if(r===this.data.length)throw Error(\\\"parse object incomplete at end\\\");if(r=this.skipIgnored(r),125===this.data[r]){r++;break}let e=(a=s,!t||t.start&&a<t.start||t.limit&&a>=t.start+t.limit?null:t&&(t.objectKeys||t.objectNodes||void 0!==t.objectKey)?{path:t.path,value:null}:null);if(r=this.parseString(r,e),e&&t&&t.objectKeys&&o.push(e.value),r=this.skipIgnored(r),58!==this.data[r])throw Error(`parse object unexpected token ${u(this.data[r])} at ${r}. Expected :`);r++,r=this.skipIgnored(r);let i=null;if(e&&t&&(t.objectNodes||e.value===t.objectKey)&&(i={path:t.path,nodeInfo:new d(this,r,[...t.path,e.value])}),r=this.parseValue(r,i),r=this.skipIgnored(r),i&&t.objectNodes)n.push(i.nodeInfo);else if(i&&void 0!==t.objectKey){t.objectNodes=[i.nodeInfo];return}if(s++,44===this.data[r])r++;else if(125!==this.data[r])throw Error(`parse object unexpected token ${u(this.data[r])} at ${r}. Expected , or }`)}return t&&t.nodeInfo&&(t.nodeInfo.type=\\\"object\\\",t.nodeInfo.length=s,t.nodeInfo.chars=r-e),t&&t.objectKeys&&(t.objectKeys=o),t&&t.objectNodes&&(t.objectNodes=n),r}parseArray(e,t){let r=e+1,s=0;for(;r<=this.data.length;){var o;if(r===this.data.length)throw Error(\\\"parse array incomplete at end\\\");if(r=this.skipIgnored(r),93===this.data[r]){r++;break}let e=null;if(o=s,!(!t||t.start&&o<t.start||t.limit&&o>=t.start+t.limit)&&t.arrayNodes&&(e={path:t.path,nodeInfo:new d(this,r,[...t.path,s.toString()])}),r=this.parseValue(r,e),e&&t.arrayNodes.push(e.nodeInfo),r=this.skipIgnored(r),s++,44===this.data[r])r++;else if(93!==this.data[r])throw Error(`parse array unexpected token ${u(this.data[r])} at ${r}. Expected , or ]`)}return t&&t.nodeInfo&&(t.nodeInfo.type=\\\"array\\\",t.nodeInfo.length=s,t.nodeInfo.chars=r-e),r}parseString(e,t){let r=e,s=34===this.data[r]?34:39,o=!1,n=0;for(r++;r<=this.data.length;r++){if(r===this.data.length)throw Error(\\\"parse string incomplete at end\\\");if(!o&&this.data[r]===s){r++;break}!(o=92===this.data[r]&&!o)&&n++}return t&&t.nodeInfo&&(t.nodeInfo.type=\\\"string\\\",t.nodeInfo.length=n,t.nodeInfo.chars=r-e),t&&void 0!==t.value&&(t.value=JSON.parse(u(this.data.subarray(e,r)))),r}parseNumber(e,t){let r=e;return 45===this.data[r]&&r++,r=this.parseDigits(r),46===this.data[r]&&(r++,r=this.parseDigits(r)),(69===this.data[r]||101===this.data[r])&&(r++,(43===this.data[r]||45===this.data[r])&&r++,r=this.parseDigits(r)),t&&t.nodeInfo&&(t.nodeInfo.type=\\\"number\\\",t.nodeInfo.chars=r-e),t&&void 0!==t.value&&(t.value=JSON.parse(u(this.data.subarray(e,r)))),r}parseDigits(e){for(;this.data[e]>=48&&this.data[e]<=57;)e++;return e}parseToken(e,t,r){let s=e;for(let e=0;e<t.length;e++){if(this.data[s]!==t[e])throw Error(`Unexpected token ${u(this.data[s])} at ${s}. Expected ${u(t)}`);s++}let o=u(this.data.subarray(e,s));return r&&r.nodeInfo&&(\\\"null\\\"===o?r.nodeInfo.type=\\\"null\\\":r.nodeInfo.type=\\\"boolean\\\",r.nodeInfo.chars=s-e),r&&void 0!==r.value&&(r.value=JSON.parse(o)),s}parseNative(e,t){return JSON.parse(u(this.data.subarray(e,t)))}skipIgnored(e){for(let t=e;t<this.data.length;t++)if(-1===a.indexOf(this.data[t]))return t}}function u(e){return\\\"number\\\"==typeof e&&(e=[e]),String.fromCharCode.apply(null,e)}},{\\\"../helpers/utils\\\":\\\"501Ss\\\",\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\":\\\"kdXvs\\\"}],\\\"501Ss\\\":[function(e,t,r,s){var o=e(\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\");function n(e,t){if(isNaN(e)||e<0)throw Error(`Invalid start ${e}`);if(t&&t<0)throw Error(`Invalid limit ${t}`)}o.defineInteropFlag(r),o.export(r,\\\"assertStartLimit\\\",()=>n)},{\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\":\\\"kdXvs\\\"}],\\\"6NMJx\\\":[function(e,t,r,s){var o=e(\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\");o.defineInteropFlag(r),o.export(r,\\\"JsJsonNodeInfo\\\",()=>a),o.export(r,\\\"JsParser\\\",()=>i);var n=e(\\\"../helpers/utils\\\");class a{constructor(e,t){this.path=[],this.ref=e,this.path=t;const r=typeof e;\\\"undefined\\\"===r&&(this.type=\\\"undefined\\\"),\\\"symbol\\\"===r&&(this.type=\\\"symbol\\\"),\\\"function\\\"===r&&(this.type=\\\"function\\\"),\\\"object\\\"===r&&null===e?this.type=\\\"null\\\":\\\"object\\\"===r&&Array.isArray(e)?this.type=\\\"array\\\":this.type=r,\\\"object\\\"===this.type&&(this.length=Object.keys(e).length),(\\\"array\\\"===this.type||\\\"string\\\"===this.type)&&(this.length=e.length)}getObjectKeys(e=0,t){if(\\\"object\\\"!==this.type)throw Error(`Unsupported method on non-object ${this.type}`);(0,n.assertStartLimit)(e,t);let r=Object.keys(this.ref);return t?r.slice(e,e+t):r.slice(e)}getByIndex(e){if(\\\"object\\\"===this.type){let t=this.getObjectNodes(e,1);if(t.length)return t[0]}if(\\\"array\\\"===this.type){let t=this.getArrayNodes(e,1);if(t.length)return t[0]}}getByKey(e){return\\\"object\\\"===this.type&&this.ref.hasOwnProperty(e)?new a(this.ref[e],[...this.path,e]):\\\"array\\\"===this.type?this.getByIndex(parseInt(e)):void 0}getByPath(e){let t;if(!e)return;if(!e.length)return this;let r=e.slice(),s=this;for(;void 0!==(t=r.shift())&&s;)s=s.getByKey(t);return s}getObjectNodes(e=0,t){if(\\\"object\\\"!==this.type)throw Error(`Unsupported method on non-object ${this.type}`);return(0,n.assertStartLimit)(e,t),this.getObjectKeys(e,t).map(e=>new a(this.ref[e],[...this.path,e]))}getArrayNodes(e=0,t){if(\\\"array\\\"!==this.type)throw Error(`Unsupported method on non-array ${this.type}`);return(0,n.assertStartLimit)(e,t),(t?this.ref.slice(e,e+t):this.ref.slice(e)).map((t,r)=>new a(t,[...this.path,String(e+r)]))}getValue(){return this.ref}}class i{constructor(e){this.data=e}getRootNodeInfo(){return void 0===this.data?null:new a(this.data,[])}}},{\\\"../helpers/utils\\\":\\\"501Ss\\\",\\\"@parcel/transformer-js/src/esmodule-helpers.js\\\":\\\"kdXvs\\\"}]},[\\\"kGz5N\\\"],\\\"kGz5N\\\",\\\"parcelRequire13a7\\\",{});\\n//# sourceMappingURL=big-json-viewer.worker.js.map\\n\"], { type: 'text/javascript' });\n  const workerUrl = URL.createObjectURL(blob);\n  return new Worker(workerUrl);\n};\n","import { JsonNodeInfoBase } from '../parser/json-node-info';\n\n/**\n * Represents an interactive node in the Big Json Viewer\n */\nexport interface BigJsonViewerNode extends JsonNodeInfoBase {\n  openable: boolean;\n  value?: any;\n  children?: BigJsonViewerNode[];\n}\n\nexport interface JsonNodesStubElement extends HTMLDivElement {\n  headerElement: HTMLElement;\n  childrenElement?: HTMLElement;\n\n  isNodeOpen(): boolean;\n\n  openNode(): Promise<boolean>;\n\n  closeNode(): Promise<boolean>;\n\n  toggleNode(): Promise<boolean>;\n}\n\nexport type BigJsonViewerEvent =\n  | 'openNode' // when the user opens a single node\n  | 'closeNode' // when the user closes a node\n  | 'openedNodes' // when multiple nodes were opened e.g. by expand all or search\n  | 'openStub' // when the user opens a single stub\n  | 'closeStub' // when the user closed a stub\n  | 'copyPath';\nexport type PaginatedOption =\n  | 'first' // open only the first pagination stub\n  | 'all' // open all pagination stubs\n  | 'none';\n\nexport type TreeSearchAreaOption =\n  | 'all' // search in keys and values\n  | 'keys' // search only in keys\n  | 'values';\n\nexport interface TreeSearchMatch {\n  path: string[];\n  key?: number; // if the match was in the key, at which index\n  value?: number; // if the match was in the value, at which index\n  length: number; // length of the match\n}\n\nexport interface TreeSearchCursor {\n  /**\n   * Currently focused match\n   */\n  index: number;\n\n  /**\n   * Matches represented by their paths\n   */\n  matches: TreeSearchMatch[];\n\n  /**\n   * Navigate to the next match\n   */\n  next(): Promise<boolean>;\n\n  /**\n   * Navigate to the previous match\n   */\n  previous(): Promise<boolean>;\n\n  /**\n   * Navigate to the given match\n   */\n  navigateTo(index: number): Promise<boolean>;\n}\n\nexport interface BigJsonViewerOptions {\n  /**\n   * How many nodes to show under an object at once\n   * before pagination starts\n   * @default 50\n   */\n  objectNodesLimit?: number;\n\n  /**\n   * How many nodes to show under an array at once\n   * before pagination starts\n   * @default 50\n   */\n  arrayNodesLimit?: number;\n\n  /**\n   * Whether the label before an item should show the whole path.\n   * @default false\n   */\n  labelAsPath?: boolean;\n\n  /**\n   * What label should be displayed on the Copy Path link.\n   * Set null to disable this link\n   */\n  linkLabelCopyPath?: string | HTMLElement;\n\n  /**\n   * What label should be displayed on the Expand all link.\n   * Set null to disable this link\n   */\n  linkLabelExpandAll?: string | HTMLElement;\n\n  /**\n   * Path to the worker bundle, null by default\n   */\n  workerPath?: string;\n\n  /**\n   * Amount of the same value in arrays should be shown before they are being collapsed.\n   * Can be Infinity\n   * @default 5\n   */\n  collapseSameValue?: number;\n\n  /**\n   * Register a hook function that is called for every opened node to add additional links to a node.\n   */\n  addLinksHook?: (node: BigJsonViewerNode) => HTMLElement[];\n}\n\nexport interface BigJsonViewer {}\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$5a6657ab2d9f6108$export$8df78c6654d8a3cf","$jl3no","$bjTst","$7vO2F","initWithData","data","rootNode","BufferJsonParser","getRootNodeInfo","getRenderInfo","initWithJs","JsParser","getNodes","path","start","limit","node","getByPath","type","getObjectNodes","map","getArrayNodes","getKeyIndex","key","keys","getObjectKeys","indexOf","search","pattern","searchArea","searchJsonNodes","info","length","openable","isOpenableNode","value","getValue","$8d78a578d08ef2f3$export$57f00ad7da2077f5","subject","callback","$8d78a578d08ef2f3$var$ensureGlobal","lastIndex","match","exec","index","global","flags","ignoreCase","multiline","RegExp","source","$8d78a578d08ef2f3$export$e47f93b04bb8867c","results","push","forEach","subNode","String","$8b51f9b9b5b272ca$export$8563104a25517665","$3NxB6","$8b51f9b9b5b272ca$var$IGNORED","$8b51f9b9b5b272ca$var$NULL","split","d","charCodeAt","$8b51f9b9b5b272ca$var$TRUE","$8b51f9b9b5b272ca$var$FALSE","$8b51f9b9b5b272ca$export$c3a21231378bfea9","parser","assertStartLimit","ctx","objectKeys","parseObject","getByIndex","nodes","getByKey","objectKey","objectNodes","undefined","parseInt","p","slice","shift","arrayNodes","parseArray","parseNative","chars","ArrayBuffer","Uint16Array","TextEncoder","encode","i","skipIgnored","nodeInfo","end","parseValue","throwUnknown","char","parseString","parseNumber","parseToken","$8b51f9b9b5b272ca$var$bufToString","keyIndex","keyCtx","valueCtx","isInRange","toString","expect","esc","JSON","parse","subarray","parseDigits","token","buf","fromCharCode","apply","$63f21e5cf8cde4d8$export$dcfa27f977c5224c","isNaN","$04e605f16dc82b7e$export$ff409fe831d40557","$04e605f16dc82b7e$export$defd4a491b161b4d","ref","jsType","Array","isArray","hasOwnProperty","elements","$0089ee43e780e197$export$e4cd0dfd45d302cc","worker","requestIndex","requestCallbacks","initWorker","Promise","resolve","reject","onmessage","msg","_init","initialized","resultId","callb","onerror","console","error","postMessage","handler","args","callWorker","transfers","result","destroy","terminate","$0089ee43e780e197$export$17ddad5eb3af88a1","provider","$0096928a09a25e8f$export$6efa9165c4ad4d70","fromData","options","viewer","setData","fromObject","setObject","objectNodesLimit","arrayNodesLimit","labelAsPath","linkLabelCopyPath","linkLabelExpandAll","workerPath","collapseSameValue","currentArea","currentMark","assign","getWorkerClient","workerClient","blob","Worker","Blob","URL","createObjectURL","client","warn","service","serviceModule","BigJsonViewerService","getChildNodes","getSearchMatches","rootElement","currentPattern","getRootElement","nodeElement","getNodeElement","classList","add","element","document","createElement","jsonNode","header","getNodeHeader","headerElement","appendChild","attachInteractivity","isNodeOpen","contains","openNode","dispatchEvent","closeNode","toggleNode","openPath","openAll","maxDepth","Infinity","paginated","getOpenPaths","withStubs","attachClickToggleListener","anchor","addEventListener","preventDefault","findNodeElement","childrenElement","remove","removeChild","dispatchNodeEvent","refreshHeaders","parentElement","replaceChild","getVisibleChildren","children","getHighlightedText","text","fragment","createDocumentFragment","createTextNode","forEachMatchFromString","substring","mark","substr","openBySearch","openLimit","matches","cursor","navigateTo","openedElement","openSearchMatch","scrollIntoView","block","findMarkForMatch","next","previous","Math","min","expectIndex","label","querySelector","childNodes","cn","nodeType","Node","TEXT_NODE","textContent","ELEMENT_NODE","tagName","matchNodeElementParent","openKey","withSubs","nodeElements","getPaginationLimit","child","first","getPaginatedNodeChildren","event","createEvent","initEvent","Event","bubbles","cancelable","stubIndex","floor","stub","childNodeElement","opened","openAllChildren","getPaginationStub","addChildNodes","stubElement","href","generateAccessor","closePaginationStub","openPaginationStub","parent","lastValue","sameValueCount","getCollapseIndicator","count","keyHighlightPattern","valueHighlightPattern","generateLabel","generateTypeInfo","generateValue","generateLinks","span","typeInfo","highlightPattern","prefix","join","valueElement","stringify","getLabelNode","link","input","select","execCommand","addLinksHook","el","$bd79623745b6affc$var$demoData","simpleData","element1","element2","element3","name","element4","element5","element6","age","birthday","year","month","day","element7","jsData","element8","un","nu","largeData","list","random","entries","j","$bd79623745b6affc$var$codeElement","getElementById","$bd79623745b6affc$var$viewerElement","$bd79623745b6affc$var$pathsElement","$bd79623745b6affc$var$copiedElement","$bd79623745b6affc$var$searchElement","$bd79623745b6affc$var$searchInfoElement","$bd79623745b6affc$var$viewer","$bd79623745b6affc$var$rootNode","$bd79623745b6affc$var$loadStructureData","structure","style","display","$bd79623745b6affc$var$showData","$bd79623745b6affc$var$showPaths","_viewer","listener","log","target","errEl","$bd79623745b6affc$var$querySelectorArray","selector","querySelectorAll","load","getAttribute","loadListener","prevBtn","nextBtn"],"version":3,"file":"docs-src.36c6ce0c.js.map"}